{
  "version": "1.2",
  "lessons": [
    {
      "id": "l1_intro",
      "title": "1. Pine Script 简介与结构",
      "subtitle": "Hello Pine! 脚本结构与版本声明",
      "concept": "<h3>什么是 Pine Script？</h3>\n<p>Pine Script 是 TradingView 的图表脚本语言，专门用来写<b>指标（indicator）</b>和<b>策略（strategy）</b>。它的执行模型是“按时间序列逐根计算”：历史回放时会从最早一根 K 线开始，逐根执行到最新一根。</p>\n<div class=\"detail-box\">\n  <h4>输入 / 输出（先建立正确的心智模型）</h4>\n  <ul>\n    <li><b>输入:</b> 图表数据（open/high/low/close/volume）、时间（time）、标的信息（syminfo.*）以及你的 <code>input.*</code> 参数。</li>\n    <li><b>输出:</b> 指标脚本输出曲线/形状/标签；策略脚本额外输出回测订单、权益曲线与统计。</li>\n  </ul>\n</div>\n<h3>脚本最小结构</h3>\n<ul>\n  <li><b>版本声明:</b> <code>//@version=5</code></li>\n  <li><b>声明语句（二选一）:</b> <code>indicator()</code> 或 <code>strategy()</code></li>\n  <li><b>主逻辑:</b> 变量、计算、绘图/下单</li>\n</ul>\n<h3>边界与注意事项</h3>\n<ul>\n  <li><b>历史长度不足会得到 na:</b> 例如 20 周期均线在前 19 根无法计算，后续逻辑要用 <code>na</code>/<code>nz()</code> 处理。</li>\n  <li><b>不要“偷看未来”:</b> 多周期/外部数据引用要理解 <code>request.security</code> 的对齐与确认机制，否则回测会虚高。</li>\n  <li><b>性能:</b> 尽量复用内置函数，避免在每根 K 线上创建大量 label/line；需要对象时优先只在 <code>barstate.islast</code> 创建。</li>\n</ul>\n<h3>进阶补充：深入理解执行模型</h3>\n<h4>1. 执行模型（Execution Model）</h4>\n<p>Pine Script 的运行机制与普通 Python 脚本完全不同。它不是只运行一次，而是<b>在每一根 K 线上重新运行一遍整个脚本</b>。</p>\n<ul>\n  <li><b>历史回放（Historical Bars）：</b> 脚本从图表最左侧的第一根 K 线开始，按顺序执行到最新一根。每执行完一根，计算结果（变量值、绘图状态）会被保存到时间序列中。</li>\n  <li><b>实时更新（Realtime Bars）：</b> 当脚本运行到最后一根（实时 K 线）时，每次价格变动（Tick）都会触发脚本重新运行。这意味着在实时 K 线未收盘（Confirmed）之前，变量值可能会不断跳变（Repainting）。</li>\n  <li><b>Bar 状态变量：</b> 使用 <code>barstate.isconfirmed</code> 来判断当前 K 线是否已收盘（不再变化），这对策略信号至关重要。</li>\n</ul>\n<h4>2. Indicator vs Strategy 的本质区别</h4>\n<ul>\n  <li><b>Indicator（指标）：</b> 轻量级，主要用于可视化。它的计算不影响回测引擎。</li>\n  <li><b>Strategy（策略）：</b> 包含回测引擎接口。<code>strategy.entry</code> 等函数不仅仅是记录，它们会与内置的 broker 模拟器交互，处理滑点、手续费、资金管理，并生成回测报告。</li>\n</ul>\n<h4>3. 常见陷阱：重绘（Repainting）</h4>\n<p>如果在实时 K 线（未确认状态）触发了信号并立即报警，但随后价格回落导致信号消失，这就是“信号闪烁”或“重绘”。<b>解决方案：</b> 始终在 <code>barstate.isconfirmed</code> 为真时才确认信号。</p>",
      "summary": [
        "必须以 //@version=5 开头，且 indicator/strategy 二选一",
        "脚本按 K 线逐根执行，变量默认是时间序列（series）",
        "输入来自 OHLCV、time、syminfo 与 input.* 参数",
        "输出是绘图对象；策略额外输出回测交易与统计",
        "历史不足会产生 na，逻辑里要显式处理",
        "多周期引用要避免未来函数导致回测虚高"
      ],
      "pine_code": "//@version=5\nindicator(\"Hello Pine\")\n\n// 绘制收盘价\nplot(close)",
      "python_code": "# Python (Backtrader 示例)\nclass HelloStrategy(bt.Strategy):\n    def next(self):\n        # 对应 plot(close)\n        # Backtrader 自动处理绘图\n        pass\n\n# Python (Pandas 示例)\nimport matplotlib.pyplot as plt\ndf['close'].plot()",
      "quiz": [
        {
          "q": "Pine Script v5 脚本的第一行必须是什么？",
          "choices": [
            {
              "text": "import pandas",
              "isCorrect": false
            },
            {
              "text": "//@version=5",
              "isCorrect": true
            },
            {
              "text": "indicator()",
              "isCorrect": false
            }
          ],
          "explain": "所有 v5 脚本必须以 //@version=5 开头，否则会被视为旧版本。"
        },
        {
          "q": "indicator() 函数的主要用途是什么？",
          "choices": [
            {
              "text": "进行回测",
              "isCorrect": false
            },
            {
              "text": "显示指标和图表",
              "isCorrect": true
            },
            {
              "text": "下单交易",
              "isCorrect": false
            }
          ],
          "explain": "indicator() 声明脚本为指标，主要用于计算和绘图；strategy() 用于回测和模拟交易。"
        },
        {
          "q": "Pine Script 代码的执行方式是怎样的？",
          "choices": [
            {
              "text": "只运行一次",
              "isCorrect": false
            },
            {
              "text": "在每根 K 线上从头到尾执行一次",
              "isCorrect": true
            },
            {
              "text": "仅在最新 K 线运行",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 的核心是自动迭代模型，脚本会针对历史数据中的每根 Bar 运行一次。"
        },
        {
          "q": "以下哪个不是 Pine Script 的内置变量？",
          "choices": [
            {
              "text": "open",
              "isCorrect": false
            },
            {
              "text": "volume",
              "isCorrect": false
            },
            {
              "text": "pandas_df",
              "isCorrect": true
            }
          ],
          "explain": "open, close, volume 等是内置变量。pandas_df 是 Python Pandas 的概念。"
        },
        {
          "q": "strategy() 和 indicator() 可以同时存在吗？",
          "choices": [
            {
              "text": "可以",
              "isCorrect": false
            },
            {
              "text": "不可以",
              "isCorrect": true
            },
            {
              "text": "仅在 v4 版本可以",
              "isCorrect": false
            }
          ],
          "explain": "一个脚本只能声明为 strategy 或 indicator 之一，不能同时声明。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l2_vars_types",
      "title": "2. 变量与数据类型",
      "subtitle": "int, float, bool, string, color, na",
      "concept": "<h3>变量是什么？先分清 series 与“普通值”</h3>\n<p>Pine 是强类型语言，但支持类型推断。更关键的是：大多数变量默认都是<b>时间序列（series）</b>，也就是“每根 K 线都有一个值”。你在代码里写的只是“当前 K 线这一次执行”的结果，历史会自动存下来供 <code>[]</code> 引用。</p>\n<div class=\"detail-box\">\n  <h4>声明与赋值（最常用三件套）</h4>\n  <ul>\n    <li><b>=</b>: 声明并赋值（每根 K 线都会重新计算一遍）。</li>\n    <li><b>var</b>: 只在第一根 K 线初始化一次，后续保持状态（常用来做计数器、累计值、数组、Map）。</li>\n    <li><b>:=</b>: 对已声明变量重新赋值（更新状态）。</li>\n  </ul>\n</div>\n<h3>常见数据类型（以及你会踩的坑）</h3>\n<ul>\n  <li><b>int / float:</b> 数值。建议在关键变量上显式声明类型（例如 <code>var float</code>），减少类型不匹配。</li>\n  <li><b>bool:</b> 条件结果，常用于信号与过滤。</li>\n  <li><b>string:</b> 文本，常用于 label/log。</li>\n  <li><b>color:</b> 颜色对象，可用 <code>color.new(base, transp)</code> 控制透明度。</li>\n  <li><b>na:</b> 缺失值（类似 Python 的 None/NaN）。任何与 na 的计算通常也会得到 na。</li>\n</ul>\n<h3>输入 / 输出与边界条件</h3>\n<ul>\n  <li><b>输入:</b> 当前 bar 的价格/成交量序列，以及你维护的状态变量（var）。</li>\n  <li><b>输出:</b> 计算出来的 series（用于 plot 或作为下游函数输入）。</li>\n  <li><b>边界:</b> 刚开始的几根 K 线历史不足会产生 na；用 <code>na(x)</code> 判断，用 <code>nz(x, fallback)</code> 给默认值。</li>\n  <li><b>性能:</b> 大对象（array/map）务必用 <code>var</code> 初始化一次，否则每根 K 线重建会明显变慢。</li>\n</ul>\n<h3>进阶补充：类型系统与状态管理</h3>\n<h4>1. 复杂的类型限定符（Qualifiers）</h4>\n<p>Pine Script 的类型不仅仅是 <code>int</code> 或 <code>float</code>，还包含“形式”（Form）：</p>\n<ul>\n  <li><b>const:</b> 编译时常量（如 <code>1</code>, <code>\"SMA\"</code>）。值永远不变。</li>\n  <li><b>input:</b> 用户在设置面板输入的值。在脚本运行期间不变，但改变设置会重启脚本。</li>\n  <li><b>simple:</b> 脚本逻辑中计算出的、但整个运行周期内保持不变的值。</li>\n  <li><b>series:</b> 最常见的形式。值可以随每根 K 线变化（如 <code>close</code>, <code>ta.sma(close, 14)</code>）。</li>\n</ul>\n<p><b>注意：</b> 你不能把 <code>series</code> 赋值给需要 <code>input</code> 或 <code>simple</code> 的参数。例如，<code>input.int(close)</code> 是错误的，因为 <code>close</code> 是变化的，而 <code>input</code> 必须是固定的。</p>\n<h4>2. na 的传播机制</h4>\n<p><code>na</code> (Not Available) 类似于 SQL 的 NULL 或 Python 的 NaN。<b>任何与 na 的运算结果通常也是 na。</b></p>\n<pre><code>a = na\nb = a + 1  // b 也是 na\nc = nz(a, 0) + 1 // c 是 1，因为 nz 把 na 变成了 0\n</code></pre>\n<h4>3. var vs varip：状态持久化</h4>\n<ul>\n  <li><b>var:</b> 变量只在第一根 K 线初始化一次。后续 K 线会自动继承上一根 K 线该变量的最终值。用于累加器、状态机。</li>\n  <li><b>varip (Intrabar Persist):</b> 类似于 <code>var</code>，但它在<b>实时 K 线的每一次 Tick 更新</b>之间也能保持状态。常用于记录单根 K 线内的最高价/最低价轨迹，或统计 Tick 数量。</li>\n</ul>",
      "summary": [
        "多数变量是 series（每根 K 线都有值）",
        "var 用于“只初始化一次”的状态变量与集合",
        ":= 用于更新已存在变量（维持状态）",
        "na 是缺失值，常用 na()/nz() 做判断与兜底",
        "显式类型（int/float）可减少类型不匹配问题"
      ],
      "pine_code": "//@version=5\nindicator(\"Vars\")\n\n// 普通变量 (每根K线重置)\na = close \n\n// 状态变量 (只初始化一次)\nvar float sum_vol = 0.0\nsum_vol := sum_vol + volume\n\nplot(sum_vol)",
      "python_code": "# Python (Backtrader)\ndef __init__(self):\n    # 对应 var (只初始化一次)\n    self.sum_vol = 0.0 \n\ndef next(self):\n    # 对应 a = close\n    a = self.data.close[0] \n    \n    # 对应 sum_vol := ...\n    self.sum_vol += self.data.volume[0]",
      "quiz": [
        {
          "q": "如果想计算历史总成交量，应该用什么关键字声明变量？",
          "choices": [
            {
              "text": "=",
              "isCorrect": false
            },
            {
              "text": "var",
              "isCorrect": true
            },
            {
              "text": "const",
              "isCorrect": false
            }
          ],
          "explain": "使用 = 声明的变量在每根 K 线都会重置。使用 var 声明的变量才会保持上一根 K 线计算后的值。"
        },
        {
          "q": "修改已声明变量的值需要用哪个操作符？",
          "choices": [
            {
              "text": "=",
              "isCorrect": false
            },
            {
              "text": ":=",
              "isCorrect": true
            },
            {
              "text": "==",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 中，= 用于声明和初始化，:= 用于给已存在的变量重新赋值。"
        },
        {
          "q": "na + 1 的结果是什么？",
          "choices": [
            {
              "text": "1",
              "isCorrect": false
            },
            {
              "text": "0",
              "isCorrect": false
            },
            {
              "text": "na",
              "isCorrect": true
            }
          ],
          "explain": "na 代表缺失值，任何与 na 的算术运算结果通常都是 na。需要用 nz() 函数处理。"
        },
        {
          "q": "如何声明一个整型变量？",
          "choices": [
            {
              "text": "int x = 10",
              "isCorrect": true
            },
            {
              "text": "float x = 10",
              "isCorrect": false
            },
            {
              "text": "x : int = 10",
              "isCorrect": false
            }
          ],
          "explain": "可以直接写 x = 10 (类型推断) 或显式声明 int x = 10。"
        },
        {
          "q": "varip 关键字的作用是什么？",
          "choices": [
            {
              "text": "定义常量",
              "isCorrect": false
            },
            {
              "text": "在实时 Bar 内不重置变量",
              "isCorrect": true
            },
            {
              "text": "定义 IP 地址",
              "isCorrect": false
            }
          ],
          "explain": "varip (var intrabar persist) 允许变量在实时 K 线的多次更新之间保持状态，而不会在每次 tick 更新时回滚。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l3_operators",
      "title": "3. 运算符与历史引用",
      "subtitle": "[] 操作符是量化的核心",
      "concept": "<h3>[] 历史引用：为什么它是量化的核心</h3>\n<p><code>[]</code> 让你在“当前这根 K 线”拿到过去的值：<code>close[1]</code> 是上一根收盘价，<code>close[2]</code> 是上两根。几乎所有信号（交叉、突破、背离）本质都是“当前 vs 过去”的比较。</p>\n<div class=\"detail-box\">\n  <h4>输入 / 输出</h4>\n  <ul>\n    <li><b>输入:</b> 任意 series（价格、指标、你自己的变量）。</li>\n    <li><b>输出:</b> 该 series 在过去某根 bar 上的值（仍然是 series）。</li>\n  </ul>\n</div>\n<h3>边界条件（必须记住）</h3>\n<ul>\n  <li><b>历史不足会返回 na:</b> 在最开始的 bar 上，<code>close[100]</code> 取不到值，会得到 na。</li>\n  <li><b>[] 不是数组索引:</b> 它只用于时间序列回看；真正的数组请用 <code>array.get</code>/<code>array.set</code>。</li>\n  <li><b>避免未来函数:</b> 多周期引用时要理解数据何时“确认”，否则你可能在小周期提前看到大周期的最终值。</li>\n</ul>\n<h3>其他常用运算符（写策略必备）</h3>\n<ul>\n  <li><b>算术:</b> +, -, *, /, %</li>\n  <li><b>比较:</b> >, <, >=, <=, ==, !=</li>\n  <li><b>逻辑:</b> and, or, not</li>\n  <li><b>三元:</b> condition ? value1 : value2（常用于条件绘图/条件止损）</li>\n</ul>\n<h3>进阶补充：历史引用与运算细节</h3>\n<h4>1. [] 操作符的深层含义</h4>\n<p><code>[]</code> 并不是数组索引，而是<b>时间序列的回溯操作符</b>。</p>\n<ul>\n  <li><code>close[0]</code> 等同于 <code>close</code>（当前值）。</li>\n  <li><code>close[1]</code> 是<b>当前脚本执行时</b>所看到的“前一根 K 线”的值。</li>\n  <li><b>重要陷阱：</b> 如果你在一个条件分支（<code>if</code>）里调用函数，该函数的内部历史一致性可能会被破坏。Pine Script 运行时会尝试处理，但最佳实践是<b>不要在条件块内调用依赖历史的函数</b>（如 <code>ta.ema</code>），除非你明确知道自己在做什么。</li>\n</ul>\n<h4>2. 赋值运算符：= vs :=</h4>\n<ul>\n  <li><code>=</code>：<b>声明并初始化</b>一个新变量。在每根 K 线执行时，都会创建一个新的局部变量。</li>\n  <li><code>:=</code>：<b>重新赋值</b>给已存在的变量。常配合 <code>var</code> 使用，用于更新状态。</li>\n</ul>\n<pre><code>// 错误示例\nvar count = 0\ncount = count + 1 // 报错！因为 count 已经存在，不能再用 = 声明\n\n// 正确示例\nvar count = 0\ncount := count + 1 // 正确，更新 count 的值\n</code></pre>",
      "summary": [
        "[] 用于回看时间序列：close[1] 是上一根",
        "历史不足会得到 na，需要逻辑里处理",
        "[] 不是数组索引，数组请用 array.get/set",
        "Pandas 用 shift(1)，Backtrader 用 [-1] 对照理解"
      ],
      "pine_code": "//@version=5\nindicator(\"Operators\")\n\n// 涨跌：当前收盘 - 昨日收盘\nchange = close - close[1]\n\n// 三元运算：如果是涨显示绿色，否则红色\nc = change > 0 ? color.green : color.red\n\nplot(change, color=c)",
      "python_code": "# Python (Pandas)\ndf['change'] = df['close'] - df['close'].shift(1)\n\n# Python (Backtrader)\nchange = self.data.close[0] - self.data.close[-1]\nc = 'green' if change > 0 else 'red'",
      "quiz": [
        {
          "q": "close[1] 在 Python Pandas 中对应什么？",
          "choices": [
            {
              "text": "df['close'].shift(1)",
              "isCorrect": true
            },
            {
              "text": "df['close'][1]",
              "isCorrect": false
            },
            {
              "text": "df['close'].iloc[1]",
              "isCorrect": false
            }
          ],
          "explain": "shift(1) 将数据向下移动一行，用于获取前一个时间点的数据。直接索引 [1] 通常是指第 2 行数据，而不是'前一行'。"
        },
        {
          "q": "在 Backtrader 中，self.data.close[0] 代表什么？",
          "choices": [
            {
              "text": "第一根 K 线",
              "isCorrect": false
            },
            {
              "text": "当前 K 线",
              "isCorrect": true
            },
            {
              "text": "最后一根 K 线",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 使用相对索引，0 是当前，-1 是前一根，-2 是前两根。"
        },
        {
          "q": "Pine Script 中 and 操作符的作用是？",
          "choices": [
            {
              "text": "逻辑或",
              "isCorrect": false
            },
            {
              "text": "逻辑与",
              "isCorrect": true
            },
            {
              "text": "位运算与",
              "isCorrect": false
            }
          ],
          "explain": "and 是逻辑与，or 是逻辑或。"
        },
        {
          "q": "表达式 high > high[1] 的含义是？",
          "choices": [
            {
              "text": "当前最高价大于前一根最高价",
              "isCorrect": true
            },
            {
              "text": "当前最高价大于所有历史最高价",
              "isCorrect": false
            },
            {
              "text": "语法错误",
              "isCorrect": false
            }
          ],
          "explain": "high[1] 是前一根 Bar 的最高价。"
        },
        {
          "q": "三元运算符 condition ? a : b 的作用是？",
          "choices": [
            {
              "text": "如果 condition 为真返回 a，否则返回 b",
              "isCorrect": true
            },
            {
              "text": "如果 condition 为真返回 b，否则返回 a",
              "isCorrect": false
            },
            {
              "text": "循环执行 a 和 b",
              "isCorrect": false
            }
          ],
          "explain": "这是标准的三元条件运算，用于简化 if-else 逻辑。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l4_control_flow",
      "title": "4. 控制流 (Control Flow)",
      "subtitle": "if, switch, for, while",
      "concept": "<h3>控制流的本质：让“规则”可执行</h3>\n<p>控制流（if/switch/for/while）用来把你的交易规则写成“机器可以严格执行”的逻辑。Pine 的特点是：这段逻辑会在每根 K 线上重复执行，所以你写的分支与循环要同时考虑<b>正确性</b>与<b>性能</b>。</p>\n<div class=\"detail-box\">\n  <h4>1) if 是表达式（非常实用）</h4>\n  <p>if 可以直接返回值，常用来生成条件序列：</p>\n  <pre><code>val = if condition\n    10\nelse\n    20</code></pre>\n</div>\n<h3>2) switch：多分支更清晰</h3>\n<p>当分支很多时，用 switch 可以避免多层 if-else。它常用于“参数选项 → 不同计算方式”的场景（例如 MA 类型选择）。</p>\n<h3>3) 循环：能不用就不用，但必须会</h3>\n<ul>\n  <li><b>for:</b> <code>for i = 0 to 10</code>（包含边界）。适合做有限窗口内的自定义累加。</li>\n  <li><b>while:</b> <code>while condition</code>。更危险，容易写出无法终止或过慢的逻辑。</li>\n</ul>\n<h3>边界与性能注意事项</h3>\n<ul>\n  <li><b>优先用内置函数:</b> ta.* 往往比你手写循环更快、更不容易出错。</li>\n  <li><b>循环次数要可控:</b> 长循环会显著拖慢脚本，甚至触发运行时间限制。</li>\n  <li><b>实时 bar:</b> 某些逻辑在实时 bar 会多次更新，必要时用 <code>barstate.isnew</code> 或 <code>barstate.isconfirmed</code> 控制触发。</li>\n</ul>\n<h3>进阶补充：控制流的副作用</h3>\n<h4>1. 循环的重置特性</h4>\n<p><code>for</code> 和 <code>while</code> 循环在每一根 K 线上都会<b>从头开始执行</b>。你不能指望循环内部的局部变量能自动跨 K 线保存，除非你引用的是外部的 <code>var</code> 变量。</p>\n<h4>2. switch 语句的威力</h4>\n<p><code>switch</code> 比多层 <code>if-else</code> 更清晰，且支持作为表达式直接返回值。</p>\n<pre><code>// 简洁的写法\nma_color = switch\n    close > ma => color.green\n    close < ma => color.red\n    => color.gray // 默认情况\n</code></pre>\n<h4>3. 关键警告：条件块中的函数调用</h4>\n<p>这是新手最容易踩的坑：<b>在 if/for/while 内部调用 ta.* 函数。</b></p>\n<pre><code>// 危险代码！\nif close > open\n    m = ta.sma(close, 20) // 只有阳线才计算 SMA？\n    // 这会导致 SMA 的内部历史数据断裂，计算结果错误！\n</code></pre>\n<p><b>正确做法：</b> 在全局作用域计算指标，在条件块内使用结果。</p>\n<pre><code>m = ta.sma(close, 20) // 始终计算，保持历史连续\nif close > open\n    // 使用 m 做逻辑判断\n</code></pre>",
      "summary": [
        "if 可以作为表达式直接返回值",
        "switch 适合多分支逻辑，结构更清晰",
        "for 循环是包含结束值的（Inclusive）",
        "能用 ta.* 就别手写循环，性能更好",
        "实时 bar 可能重复触发，必要时用 barstate 控制"
      ],
      "pine_code": "//@version=5\nindicator(\"Control Flow\")\n\n// if 作为表达式\ntrend_msg = if close > open\n    \"Bullish\"\nelse\n    \"Bearish\"\n\n// for 循环计算过去 3 天的平均 TR\nsum_tr = 0.0\nfor i = 0 to 2\n    sum_tr := sum_tr + ta.tr[i]\navg_tr = sum_tr / 3",
      "python_code": "# Python\ntrend_msg = \"Bullish\" if close > open else \"Bearish\"\n\n# 循环计算\nsum_tr = 0.0\nfor i in range(3): # 0, 1, 2\n    sum_tr += tr_series.iloc[-(i+1)]\navg_tr = sum_tr / 3",
      "quiz": [
        {
          "q": "Pine Script 中的 for i = 1 to 3 会执行几次循环？",
          "choices": [
            {
              "text": "2次 (1, 2)",
              "isCorrect": false
            },
            {
              "text": "3次 (1, 2, 3)",
              "isCorrect": true
            },
            {
              "text": "4次 (0, 1, 2, 3)",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 的 to 关键字是包含结束值的（Inclusive）。"
        },
        {
          "q": "switch 语句主要用于什么？",
          "choices": [
            {
              "text": "循环",
              "isCorrect": false
            },
            {
              "text": "多条件分支判断",
              "isCorrect": true
            },
            {
              "text": "定义变量",
              "isCorrect": false
            }
          ],
          "explain": "switch 用于替代多个嵌套的 if-else 结构，使代码更清晰。"
        },
        {
          "q": "在 Pine Script 中，while 循环什么时候停止？",
          "choices": [
            {
              "text": "当条件为 true 时",
              "isCorrect": false
            },
            {
              "text": "当条件为 false 时",
              "isCorrect": true
            },
            {
              "text": "永远不停止",
              "isCorrect": false
            }
          ],
          "explain": "while 循环在条件变为 false 时终止。"
        },
        {
          "q": "Python 的 range(1, 3) 包含 3 吗？",
          "choices": [
            {
              "text": "包含",
              "isCorrect": false
            },
            {
              "text": "不包含",
              "isCorrect": true
            }
          ],
          "explain": "Python 的 range 是左闭右开区间，range(1, 3) 生成 1, 2。"
        },
        {
          "q": "continue 关键字的作用是？",
          "choices": [
            {
              "text": "终止循环",
              "isCorrect": false
            },
            {
              "text": "跳过本次循环剩余部分，进入下一次迭代",
              "isCorrect": true
            },
            {
              "text": "退出程序",
              "isCorrect": false
            }
          ],
          "explain": "continue 跳过本次迭代，break 终止整个循环。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l6_ta_builtins",
      "title": "5. 内置技术指标 (ta 命名空间)",
      "subtitle": "SMA, EMA, RSI, MACD",
      "concept": "<h3>什么是 ta 命名空间?</h3>\n<p>在 Pine Script v5 中，所有内置的技术分析函数都归类在 <code>ta</code> (Technical Analysis) 命名空间下。这使得代码更清晰，也便于查找。</p>\n\n<h3>常用 ta 函数分类</h3>\n\n<h4>1. 移动平均与趋势 (Moving Averages)</h4>\n<table style=\"width:100%; border-collapse: collapse; margin-bottom: 20px;\">\n  <tr style=\"background: rgba(255,255,255,0.05);\">\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">函数</th>\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.sma(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">简单移动平均线 (Simple Moving Average)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.ema(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">指数移动平均线 (Exponential Moving Average)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.wma(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">加权移动平均线 (Weighted Moving Average)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.rma(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">RSI 专用移动平均 (Wilder's Smoothing)</td>\n  </tr>\n</table>\n\n<h4>2. 震荡指标 (Oscillators)</h4>\n<table style=\"width:100%; border-collapse: collapse; margin-bottom: 20px;\">\n  <tr style=\"background: rgba(255,255,255,0.05);\">\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">函数</th>\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.rsi(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">相对强弱指数 (Relative Strength Index)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.macd(source, fast, slow, signal)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">MACD 指标 (返回三个值: macd线, 信号线, 柱状图)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.cci(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">商品通道指数 (Commodity Channel Index)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.stoch(source, high, low, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">随机指标 (Stochastic Oscillator)</td>\n  </tr>\n</table>\n\n<h4>3. 信号与逻辑 (Signals)</h4>\n<table style=\"width:100%; border-collapse: collapse; margin-bottom: 20px;\">\n  <tr style=\"background: rgba(255,255,255,0.05);\">\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">函数</th>\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.crossover(series1, series2)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">上穿 (金叉)：当 series1 上穿 series2 时返回 true</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.crossunder(series1, series2)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">下穿 (死叉)：当 series1 下穿 series2 时返回 true</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.barssince(condition)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">计算自上次条件满足以来经过的 K 线根数</td>\n  </tr>\n</table>\n\n<h4>4. 极值与波动 (Extremes & Volatility)</h4>\n<table style=\"width:100%; border-collapse: collapse; margin-bottom: 20px;\">\n  <tr style=\"background: rgba(255,255,255,0.05);\">\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">函数</th>\n    <th style=\"text-align:left; padding:8px; border-bottom:1px solid #333;\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.highest(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">周期内最高值</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.lowest(source, length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">周期内最低值</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.atr(length)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">平均真实波幅 (Average True Range)</td>\n  </tr>\n  <tr>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\"><code>ta.bb(series, length, mult)</code></td>\n    <td style=\"padding:8px; border-bottom:1px solid #333;\">布林带 (Bollinger Bands)</td>\n  </tr>\n</table>\n<h3>进阶补充：内置函数的黑魔法</h3>\n<h4>1. 内部状态维护</h4>\n<p>像 <code>ta.rsi</code>, <code>ta.ema</code>, <code>ta.macd</code> 这样的函数，内部都维护着自己的历史数据缓冲区。这就是为什么必须在每根 K 线上无条件调用它们，以保证它们能“看到”完整的时间序列。</p>\n<h4>2. 命名空间</h4>\n<p>v5 版本将所有技术分析函数归类在 <code>ta.</code> (Technical Analysis) 命名空间下，数学函数在 <code>math.</code> 下。这避免了命名冲突，也让代码更易读。</p>\n<h4>3. 动态长度参数</h4>\n<p>大多数 <code>ta.*</code> 函数的 <code>length</code> 参数支持 <code>series int</code>（即每根 K 线长度可以变），但这会消耗更多性能。如果长度是固定的，建议直接传整数常量。</p>",
      "summary": [
        "所有指标函数都在 ta. 下",
        "crossover/crossunder 检测交叉信号",
        "Python 通常需要 talib 或 pandas-ta 库",
        "Backtrader 有 bt.indicators"
      ],
      "pine_code": "//@version=5\nindicator(\"TA Namespace Demo\", overlay=true)\n\n// 1. 移动平均\nma = ta.sma(close, 14)\nplot(ma, \"SMA 14\", color=color.yellow)\n\n// 2. 交叉信号\n// 检查收盘价是否上穿均线\nis_cross_up = ta.crossover(close, ma)\n\n// 3. 统计最近一次金叉以来的 K 线数\nbars_since_cross = ta.barssince(is_cross_up)\n\n// 4. 绘制信号\nplotshape(is_cross_up, style=shape.triangleup, location=location.belowbar, color=color.green)",
      "python_code": "# Python (Backtrader 对应实现)\nclass TADemo(bt.Indicator):\n    lines = ('sma', 'cross_up', 'bars_since')\n    \n    def __init__(self):\n        # 1. 移动平均\n        self.lines.sma = bt.indicators.SMA(self.data.close, period=14)\n        \n        # 2. 交叉信号 (CrossOver)\n        # bt.ind.CrossOver 返回 1.0 (上穿) 或 -1.0 (下穿)\n        self.cross = bt.indicators.CrossOver(self.data.close, self.lines.sma)\n        \n    def next(self):\n        # Backtrader 中获取\"自上次...以来\"比较麻烦\n        # 通常需要自己维护计数器\n        pass\n\n# Python (Pandas TA 库)\nimport pandas_ta as ta\ndf.ta.sma(length=14, append=True)\ndf.ta.rsi(length=14, append=True)",
      "quiz": [
        {
          "q": "如何判断 ma1 上穿 ma2？",
          "choices": [
            {
              "text": "ma1 > ma2",
              "isCorrect": false
            },
            {
              "text": "ta.crossover(ma1, ma2)",
              "isCorrect": true
            },
            {
              "text": "ta.cross(ma1, ma2)",
              "isCorrect": false
            }
          ],
          "explain": "ta.crossover 专门用于检测上穿（当前大于且上一根小于等于）。"
        },
        {
          "q": "ta.rsi(close, 14) 计算的是什么？",
          "choices": [
            {
              "text": "移动平均线",
              "isCorrect": false
            },
            {
              "text": "相对强弱指数",
              "isCorrect": true
            },
            {
              "text": "布林带",
              "isCorrect": false
            }
          ],
          "explain": "RSI (Relative Strength Index)。"
        },
        {
          "q": "ta.ema 与 ta.sma 的区别？",
          "choices": [
            {
              "text": "EMA 是加权平均，SMA 是简单平均",
              "isCorrect": true
            },
            {
              "text": "SMA 计算更快",
              "isCorrect": false
            },
            {
              "text": "没有区别",
              "isCorrect": false
            }
          ],
          "explain": "EMA (Exponential Moving Average) 对近期数据赋予更高权重。"
        },
        {
          "q": "ta.lowest(low, 20) 的作用是？",
          "choices": [
            {
              "text": "计算过去 20 根 K 线的最低价",
              "isCorrect": true
            },
            {
              "text": "计算当前最低价",
              "isCorrect": false
            },
            {
              "text": "计算 20 天前的最低价",
              "isCorrect": false
            }
          ],
          "explain": "ta.lowest 返回指定长度窗口内的最小值。"
        },
        {
          "q": "在 Python Backtrader 中，SMA 指标在哪里？",
          "choices": [
            {
              "text": "bt.indicators.SMA",
              "isCorrect": true
            },
            {
              "text": "bt.SMA",
              "isCorrect": false
            },
            {
              "text": "pandas.SMA",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 的指标库在 bt.indicators 包下。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l7_plotting",
      "title": "6. 绘图与视觉化",
      "subtitle": "plot, plotshape, bgcolor",
      "concept": "<h3>核心绘图函数详解</h3>\n<p>Pine Script 的绘图系统分为<b>静态图表 (Chart)</b> 和 <b>动态对象 (Objects)</b> 两大类。以下是详细参数说明与演示。</p>\n\n<h4>1. plot() - 通用绘图</h4>\n<p>最常用的函数，用于绘制连续数据。</p>\n<div class=\"detail-box\">\n    <h4>关键参数详解</h4>\n    <ul>\n        <li><b>series</b>: 要绘制的数据 (如 <code>close</code>, <code>ta.sma(close, 14)</code>)。</li>\n        <li><b>title</b>: 脚本设置中的显示名称 (String)。</li>\n        <li><b>color</b>: 颜色，支持透明度 (<code>color.new(color.red, 50)</code>)。</li>\n        <li><b>linewidth</b>: 线宽 (1-4)。</li>\n        <li><b>style</b>: 绘图样式。\n            <ul>\n                <li><code>plot.style_line</code> (默认): 连续线。</li>\n                <li><code>plot.style_stepline</code>: 阶梯线。</li>\n                <li><code>plot.style_histogram</code>: 直方图 (柱状图)。</li>\n                <li><code>plot.style_columns</code>: 柱状图 (类似成交量)。</li>\n                <li><code>plot.style_circles</code>: 圆点。</li>\n                <li><code>plot.style_area</code>: 面积图。</li>\n            </ul>\n        </li>\n        <li><b>offset</b>: 向左/右平移 K 线根数 (正数向右，负数向左)。</li>\n    </ul>\n</div>\n<table style=\"width:100%; border-collapse: collapse; margin-bottom: 20px; font-size: 13px;\">\n    <tr style=\"background: rgba(255,255,255,0.05);\">\n        <th style=\"padding:8px; border-bottom:1px solid #333; text-align:left;\">场景</th>\n        <th style=\"padding:8px; border-bottom:1px solid #333; text-align:left;\">代码示例</th>\n    </tr>\n    <tr>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\">标准均线</td>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\"><code style=\"color:var(--accent-primary);\">plot(ta.sma(close, 20), title=\"MA 20\", color=color.yellow, linewidth=2)</code></td>\n    </tr>\n    <tr>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\">直方图 (MACD)</td>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\"><code style=\"color:var(--accent-primary);\">plot(hist, style=plot.style_histogram, color=hist>=0 ? color.red : color.green)</code></td>\n    </tr>\n    <tr>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\">未来偏移 (一目云)</td>\n        <td style=\"padding:8px; border-bottom:1px solid #333;\"><code style=\"color:var(--accent-primary);\">plot(close, offset=26, color=color.blue) // 向右平移26根</code></td>\n    </tr>\n</table>\n\n<h4>2. plotshape() - 形状标记</h4>\n<p>用于标记买卖信号、高低点等离散事件。</p>\n<div class=\"detail-box\">\n    <h4>关键参数详解</h4>\n    <ul>\n        <li><b>style</b>: 形状类型。\n            <code>shape.triangleup</code>, <code>shape.triangledown</code>, <code>shape.labelup</code>, <code>shape.labeldown</code>, <code>shape.circle</code>, <code>shape.xcross</code> 等。\n        </li>\n        <li><b>location</b>: 垂直位置。\n            <code>location.abovebar</code> (K线上方), <code>location.belowbar</code> (下方), <code>location.top</code> (窗口顶部), <code>location.bottom</code>, <code>location.absolute</code> (指定价格)。\n        </li>\n        <li><b>size</b>: 大小。<code>size.auto</code>, <code>size.tiny</code>, <code>size.small</code>, <code>size.normal</code>, <code>size.large</code>, <code>size.huge</code>。</li>\n        <li><b>text</b>: 形状旁边的短文本。</li>\n        <li><b>textcolor</b>: 文本颜色。</li>\n    </ul>\n</div>\n<p><b>示例：</b></p>\n<pre><code class=\"language-javascript\">\n// 在金叉处，K 线下方标记绿色向上三角形，并写 \"Buy\"\nplotshape(ta.crossover(ma1, ma2), style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, text=\"Buy\", textcolor=color.white)\n</code></pre>\n\n<h4>3. plotchar() - 字符标记</h4>\n<p>比 plotshape 更轻量，或用于调试。</p>\n<ul>\n    <li><b>char</b>: 任意单字符 (如 \"★\", \"$\", \"B\")。</li>\n</ul>\n<p><b>示例：</b></p>\n<pre><code class=\"language-javascript\">\n// 在创新高时标记 \"★\"\nplotchar(high > ta.highest(high[1], 20), char=\"★\", location=location.abovebar, color=color.yellow)\n</code></pre>\n\n<h4>4. bgcolor() & fill() - 背景与填充</h4>\n<div class=\"detail-box\">\n    <h4>参数详解</h4>\n    <ul>\n        <li><b>bgcolor(color, offset)</b>: 填充整个 K 线的背景条。通常配合条件表达式使用。</li>\n        <li><b>fill(plot1, plot2, color)</b>: 必须接收两个 <code>plot()</code> 函数的 ID。</li>\n    </ul>\n</div>\n<p><b>示例：</b></p>\n<pre><code class=\"language-javascript\">\n// 1. 背景色：RSI 超买时显示红色背景 (透明度 90%)\nbgcolor(rsi > 70 ? color.new(color.red, 90) : na)\n\n// 2. 填充：布林带\nu = plot(upper)\nl = plot(lower)\nfill(u, l, color=color.new(color.blue, 95))\n</code></pre>\n\n<h4>5. 动态对象 (Objects) - 高级绘图</h4>\n<p>需要在特定坐标 (x, y) 绘图时使用。x 轴通常是 <code>bar_index</code> (K线索引) 或 <code>time</code> (时间戳)。</p>\n<table style=\"width:100%; border-collapse: collapse; font-size: 13px;\">\n    <tr>\n        <th style=\"text-align:left; border-bottom:1px solid #555; padding: 5px;\">类型</th>\n        <th style=\"text-align:left; border-bottom:1px solid #555; padding: 5px;\">函数与参数</th>\n        <th style=\"text-align:left; border-bottom:1px solid #555; padding: 5px;\">示例</th>\n    </tr>\n    <tr>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><b>Line</b></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>line.new(x1, y1, x2, y2, color, width, style)</code></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>line.new(bar_index[10], high[10], bar_index, high, width=2)</code></td>\n    </tr>\n    <tr>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><b>Label</b></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>label.new(x, y, text, style, color, textcolor)</code></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>label.new(bar_index, high, \"Resist\", style=label.style_label_down)</code></td>\n    </tr>\n    <tr>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><b>Box</b></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>box.new(left, top, right, bottom, border_color, bgcolor)</code></td>\n        <td style=\"padding:5px; border-bottom:1px solid #333;\"><code>box.new(bar_index[5], high, bar_index, low, bgcolor=color.new(color.blue, 80))</code></td>\n    </tr>\n</table>\n<h3>进阶补充：绘图性能与调试</h3>\n<h4>1. 绘图类型选择</h4>\n<ul>\n  <li><code>plot()</code>: 绘制连续曲线（最常用）。</li>\n  <li><code>plotshape()</code>: 在 K 线上下方绘制图标（如箭头、星号），适合标记买卖点。</li>\n  <li><code>plotchar()</code>: 绘制任意 ASCII 字符，也常用于调试（因为它可以打印数值，虽然是在图表上）。</li>\n  <li><code>plotarrow()</code>: 绘制向上/向下的长箭头，通常用于表示差值大小。</li>\n</ul>\n<h4>2. 动态对象管理（Garbage Collection）</h4>\n<p><code>line.new</code>, <code>label.new</code>, <code>box.new</code> 创建的对象不仅消耗内存，还有数量限制（默认约 50 个）。</p>\n<ul>\n  <li><b>自动删除：</b> 当对象数量超过限制时，最旧的对象会被自动删除（垃圾回收）。</li>\n  <li><b>手动管理：</b> 使用 <code>line.delete(id)</code> 手动清理不再需要的对象。</li>\n  <li><b>最佳实践：</b> 如果只是为了显示最新状态，不要在每根 K 线都 new 一个 label，而是用 <code>var</code> 创建一个 label，然后用 <code>label.set_xy</code> 和 <code>label.set_text</code> 更新它。</li>\n</ul>\n<pre><code>// 高性能写法：只维护一个 Label 显示最新价格\nvar label myLabel = label.new(bar_index, close, text=str.tostring(close))\nlabel.set_xy(myLabel, bar_index, close)\nlabel.set_text(myLabel, str.tostring(close))\n</code></pre>",
      "summary": [
        "plot() 支持 style, linewidth, color, offset 等丰富参数",
        "plotshape() 用于信号标记，支持 text 和 location",
        "color.new(color, transp) 用于设置透明度 (0-100)",
        "动态对象 (line/label) 用于更灵活的几何绘图"
      ],
      "pine_code": "//@version=5\nindicator(\"Detailed Plotting\", overlay=true)\n\n// --- 1. plot() 详细参数演示 ---\n// 基础均线：黄色，线宽2\nma = ta.sma(close, 20)\np1 = plot(ma, title=\"MA Line\", color=color.yellow, linewidth=2, style=plot.style_line)\n\n// 偏移均线：向右平移 5 根，白色虚线 (模拟预测或一目均衡表)\n// 注意：style 参数不仅有 line，还有 stepline, circles, cross 等\nplot(ma, title=\"Offset MA\", color=color.white, linewidth=1, style=plot.style_line, offset=5)\n\n// --- 2. fill() 区域填充 ---\n// 模拟一个下轨\nlower = ma * 0.98\np2 = plot(lower, \"Lower Channel\", display=display.none) // 不显示线条本身\n// 填充 p1 和 p2 之间，使用 90% 透明度的黄色\nfill(p1, p2, color=color.new(color.yellow, 90), title=\"Channel Fill\")\n\n// --- 3. plotshape() 信号标记 ---\n// 场景：RSI 下穿 70 (卖出信号)\nis_sell = ta.crossunder(ta.rsi(close, 14), 70)\n\nplotshape(is_sell, \n     title=\"Sell Signal\", \n     style=shape.labeldown,   // 形状：向下标签\n     location=location.abovebar, // 位置：K线上方\n     color=color.red,         // 形状颜色\n     size=size.normal,        // 大小\n     text=\"SELL\",             // 文本内容\n     textcolor=color.white,   // 文本颜色\n     offset=0                 // 偏移\n)\n\n// --- 4. plotchar() 字符标记 ---\n// 场景：阳线，在下方标记一个小 \"+\"\nplotchar(close > open, \n     title=\"Up Bar\", \n     char=\"+\", \n     location=location.belowbar, \n     color=color.green, \n     size=size.tiny\n)\n\n// --- 5. bgcolor() 背景高亮 ---\n// 场景：RSI 超卖 (<30) 时，背景变红\nis_oversold = ta.rsi(close, 14) < 30\n// 使用 color.new 设置透明度非常重要，否则会遮挡K线\nbgcolor(is_oversold ? color.new(color.red, 80) : na, title=\"Oversold BG\")\n\n// --- 6. 动态对象 (Line & Label) ---\n// 仅在最后一根 K 线绘制，避免历史数据充满垃圾对象\nif barstate.islast\n    // 画一条从 10 根前 high 到当前 high 的线\n    line.new(x1=bar_index - 10, y1=high[10], \n             x2=bar_index, y2=high, \n             color=color.fuchsia, width=2, style=line.style_dashed)\n             \n    // 在当前高点打标签\n    label.new(x=bar_index, y=high, \n              text=\"High: \" + str.tostring(high, \"#.##\"), \n              style=label.style_label_lower_left,\n              color=color.fuchsia, textcolor=color.white)\n",
      "python_code": "# Python (使用 mplfinance 模拟 Pine 绘图参数)\nimport mplfinance as mpf\nimport pandas as pd\n\n# 准备数据 (假设 df 是 DataFrame)\n# ...\n\n# 1. 构造 addplot 列表\napds = []\n\n# plot(ma, color=color.yellow, linewidth=2)\napds.append(mpf.make_addplot(df['MA20'], color='yellow', width=2))\n\n# plotshape(is_sell, type='scatter', marker='v', markersize=100)\n# mplfinance 需要创建一个全是 NaN 的序列，只在信号点有值\nsell_signal_series = df['High'] * 1.01\nsell_signal_series[~df['IsSell']] = float('nan')\napds.append(mpf.make_addplot(sell_signal_series, type='scatter', markersize=100, marker='v', color='red'))\n\n# fill_between (区域填充)\n# 需要在 mpf.plot() 的 fill_between 参数中设置\nfill_config = dict(y1=df['MA20'].values, y2=df['Lower'].values, alpha=0.1, color='yellow')\n\n# 绘图\n# style 参数对应 Pine 的 plot.style (candle, line 等)\nmpf.plot(df, \n         type='candle', \n         style='charles', \n         addplot=apds, \n         fill_between=fill_config,\n         volume=True,\n         title=\"Python Plotting Demo\")\n\n# 关于 Line 和 Label (动态对象)\n# mplfinance 支持 alines (arbitrary lines) 和 tlines (trend lines)\n# mpf.plot(..., alines=dict(alines=[(date1, price1), (date2, price2)], colors=['fuchsia'], linewidths=2))\n",
      "quiz": [
        {
          "q": "想在 K 线图背景上标记颜色，应该用哪个函数？",
          "choices": [
            {
              "text": "plot()",
              "isCorrect": false
            },
            {
              "text": "bgcolor()",
              "isCorrect": true
            },
            {
              "text": "fill()",
              "isCorrect": false
            }
          ],
          "explain": "bgcolor() 用于设置背景颜色。fill() 是用于填充两条 plot 线之间的区域。"
        },
        {
          "q": "plotshape 与 plotchar 的区别？",
          "choices": [
            {
              "text": "plotshape 画几何形状，plotchar 画字符",
              "isCorrect": true
            },
            {
              "text": "没有区别",
              "isCorrect": false
            },
            {
              "text": "plotchar 性能更高",
              "isCorrect": false
            }
          ],
          "explain": "plotshape 预设了 triangle, arrow 等形状；plotchar 可以显示任意字符。"
        },
        {
          "q": "如何设置颜色的透明度？",
          "choices": [
            {
              "text": "color.new(color.red, 50)",
              "isCorrect": true
            },
            {
              "text": "color.red(50)",
              "isCorrect": false
            },
            {
              "text": "rgb(255, 0, 0, 0.5)",
              "isCorrect": false
            }
          ],
          "explain": "v5 中推荐使用 color.new(base_color, transp) 设置透明度，transp 为 0-100。"
        },
        {
          "q": "fill() 函数需要什么参数？",
          "choices": [
            {
              "text": "两个 plot ID",
              "isCorrect": true
            },
            {
              "text": "两个价格",
              "isCorrect": false
            },
            {
              "text": "两个颜色",
              "isCorrect": false
            }
          ],
          "explain": "fill() 接收两个由 plot() 返回的 ID，填充它们之间的区域。"
        },
        {
          "q": "Backtrader 默认使用什么绘图库？",
          "choices": [
            {
              "text": "Matplotlib",
              "isCorrect": true
            },
            {
              "text": "Plotly",
              "isCorrect": false
            },
            {
              "text": "D3.js",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 默认集成 Matplotlib 进行绘图。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l11_inputs",
      "title": "7. 交互输入 (Inputs)",
      "subtitle": "让脚本更灵活",
      "concept": "<h3>交互式输入</h3>\n<p><code>input()</code> 函数允许用户在不修改代码的情况下调整脚本参数。Pine Script v5 提供了类型安全的输入函数。</p>\n<div class=\"detail-box\">\n    <h4>常用输入类型</h4>\n    <ul>\n        <li><code>input.int(defval, title, minval, maxval)</code>: 整数</li>\n        <li><code>input.float(defval, title)</code>: 浮点数</li>\n        <li><code>input.bool(defval, title)</code>:布尔开关</li>\n        <li><code>input.string(defval, title, options=[...])</code>: 下拉菜单</li>\n        <li><code>input.color(defval, title)</code>: 颜色选择器</li>\n        <li><code>input.source(close, title)</code>: 数据源选择 (如 open, hl2)</li>\n        <li><code>input.symbol(syminfo.tickerid, title)</code>: 标的选择</li>\n        <li><code>input.timeframe(\"D\", title)</code>: 时间周期选择</li>\n    </ul>\n    <h4>组织参数</h4>\n    <p>使用 <code>group</code>, <code>inline</code>, <code>tooltip</code> 参数可以美化设置面板。</p>\n</div>\n<h3>进阶补充：构建专业级配置面板</h3>\n<h4>1. 组织参数（Group & Inline）</h4>\n<p>让你的脚本设置界面更整洁：</p>\n<ul>\n  <li><code>group</code>: 将参数分组，显示标题。</li>\n  <li><code>inline</code>: 将多个参数放在同一行显示（inline 字符串相同的参数会在一行）。</li>\n</ul>\n<pre><code>i_len = input.int(14, \"Length\", group=\"Strategy\", inline=\"p1\")\ni_src = input.source(close, \"Source\", group=\"Strategy\", inline=\"p1\")\n</code></pre>\n<h4>2. 交互式输入</h4>\n<ul>\n  <li><code>input.time</code>: 选择特定的日期时间（常用于回测范围过滤）。</li>\n  <li><code>input.symbol</code>: 允许用户选择另一个交易对进行对比分析。</li>\n</ul>\n<h4>3. 确认机制</h4>\n<p><code>confirm=true</code> 参数（在 <code>input.*</code> 中）会在脚本加载前弹窗让用户确认参数。这在处理复杂计算或重型脚本时很有用。</p>",
      "summary": [
        "input.* 系列函数用于创建设置选项",
        "options 参数可以创建下拉列表",
        "group 参数可以将选项分组显示",
        "source 输入允许用户选择计算基于收盘价还是开盘价等",
        "input 的值是“用户配置”，代码里不要试图动态修改它",
        "复杂脚本建议用 group/inline/tooltip 让设置更易用"
      ],
      "pine_code": "//@version=5\nindicator(\"Inputs Demo\", overlay=true)\n\n// --- 基础输入 ---\nlen = input.int(14, \"Length\", minval=1, tooltip=\"均线周期\")\nsrc = input.source(close, \"Source\")\nis_show = input.bool(true, \"Show Plot\")\n\n// --- 分组与下拉菜单 ---\ngrp_style = \"Style Settings\"\ncol = input.color(color.red, \"Line Color\", group=grp_style)\ntype = input.string(\"SMA\", \"MA Type\", options=[\"SMA\", \"EMA\"], group=grp_style)\n\n// --- 逻辑使用 ---\nfloat ma_val = na\nif type == \"SMA\"\n    ma_val := ta.sma(src, len)\nelse\n    ma_val := ta.ema(src, len)\n\nplot(is_show ? ma_val : na, color=col, linewidth=2)",
      "python_code": "# Python (Streamlit 示例)\nimport streamlit as st\nimport pandas_ta as ta\n\n# 对应 input.int\nlength = st.number_input(\"Length\", min_value=1, value=14)\n# 对应 input.string options\nma_type = st.selectbox(\"MA Type\", [\"SMA\", \"EMA\"])\n# 对应 input.bool\nis_show = st.checkbox(\"Show Plot\", value=True)\n\nif ma_type == \"SMA\":\n    ma = ta.sma(df['close'], length)\nelse:\n    ma = ta.ema(df['close'], length)",
      "quiz": [
        {
          "q": "如何创建一个带有下拉菜单的输入项？",
          "choices": [
            {
              "text": "input.string(..., options=['A', 'B'])",
              "isCorrect": true
            },
            {
              "text": "input.list(...)",
              "isCorrect": false
            },
            {
              "text": "input.menu(...)",
              "isCorrect": false
            }
          ],
          "explain": "使用 input.string 并配合 options 参数列表即可生成下拉菜单。"
        },
        {
          "q": "想要限制输入的整数最小值为 1，应该用哪个参数？",
          "choices": [
            {
              "text": "limit=1",
              "isCorrect": false
            },
            {
              "text": "minval=1",
              "isCorrect": true
            },
            {
              "text": "low=1",
              "isCorrect": false
            }
          ],
          "explain": "input.int 和 input.float 支持 minval 和 maxval 参数。"
        },
        {
          "q": "input.source 默认通常允许用户选择什么？",
          "choices": [
            {
              "text": "开盘价、收盘价、最高价等序列",
              "isCorrect": true
            },
            {
              "text": "本地文件",
              "isCorrect": false
            }
          ],
          "explain": "input.source 允许用户在 UI 上选择计算指标基于哪个价格序列（如 close, hl2 等）。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l12_debugging",
      "title": "8. 调试技巧 (Debugging)",
      "subtitle": "Pine Logs 与 绘图调试",
      "concept": "<h3>调试方法</h3>\n<p>编写复杂脚本时，知道变量当前的值至关重要。Pine Script v5 提供了两种主要的调试方式。</p>\n\n<h4>1. 可视化调试 (Visual Debugging)</h4>\n<p>最传统的方法是将变量画在图上：</p>\n<ul>\n    <li><code>plot(variable)</code>: 画在副图观察数值变化。</li>\n    <li><code>plotchar(bar_index, \"Bar Index\", \"\", location.top)</code>: 在数据窗口显示数值。</li>\n    <li><code>label.new(...)</code>: 在特定 K 线上打印文本。</li>\n</ul>\n\n<h4>2. Pine Logs (日志调试) - 推荐</h4>\n<p>v5 引入了 <code>log.*</code> 函数，可以在专门的 \"Pine Logs\" 面板中查看输出，不会干扰图表。</p>\n<ul>\n    <li><code>log.info(message)</code>: 打印一般信息。</li>\n    <li><code>log.error(message)</code>: 打印错误（红色）。</li>\n    <li><code>log.warning(message)</code>: 打印警告（橙色）。</li>\n</ul>\n<p><b>提示:</b> 字符串拼接可以使用 <code>str.tostring(value)</code> 或 <code>str.format()</code>。</p>\n<h3>更高效的排错流程（从现象到根因）</h3>\n<ul>\n  <li><b>先画状态再画数值:</b> 先用 <code>plotchar()</code> 标出条件，再定位变量。</li>\n  <li><b>缩小范围:</b> 把复杂策略拆成几段条件，逐段验证，避免一次看太多线索。</li>\n  <li><b>锁定重绘问题:</b> 多周期/未来偏移相关逻辑，优先检查是否使用了未确认数据。</li>\n</ul>\n<h3>边界与注意</h3>\n<ul>\n  <li><b>日志数量:</b> 过多 log 会影响可读性，建议只在关键分支或最后一根输出。</li>\n  <li><b>对象上限:</b> label/line/box 有数量限制，实战里要复用或删除旧对象。</li>\n</ul>\n<h3>进阶补充：Pine Script 调试艺术</h3>\n<h4>1. Pine Logs (v5 新神器)</h4>\n<p>以前我们只能用 <code>plotchar</code> 把数值印在图上，不仅乱而且难以查看历史。现在可以使用 <b>Pine Logs</b>：</p>\n<pre><code>if barstate.islast\n    log.info(\"Current Price: {0}, RSI: {1}\", close, myRsi)\n</code></pre>\n<p>在编辑器底部的 \"Pine Logs\" 面板中查看输出，支持时间戳过滤。</p>\n<h4>2. 可视化调试</h4>\n<ul>\n  <li><b>背景色：</b> 用 <code>bgcolor()</code> 根据条件改变背景色，快速定位逻辑触发点。</li>\n  <li><b>画线：</b> 用 <code>hline()</code> 或 <code>plot()</code> 把中间变量画出来，看是否符合预期。</li>\n  <li><b>表格：</b> 用 <code>table.new</code> 在图表角落显示一个Dashboard，实时监控多个变量的值。</li>\n</ul>",
      "summary": [
        "log.info() 是最现代的调试工具",
        "plotchar 可以把数值显示在 Data Window 而不干扰图表",
        "str.tostring(val) 用于将数字转为字符串",
        "大量 label/line 会触发对象数量上限，调试对象建议只在最后一根创建",
        "日志不要每根都刷屏，必要时加条件或只在 islast 输出",
        "把边界条件写进逻辑里：na、对象上限、确认时机"
      ],
      "pine_code": "//@version=5\nindicator(\"Debugging Demo\", overlay=true)\n\n// 场景：调试一个交叉条件\nfast = ta.sma(close, 10)\nslow = ta.sma(close, 20)\ncross = ta.crossover(fast, slow)\n\n// 方法 1: 绘图调试\nplot(fast, \"Fast\", color.green)\nplotchar(cross, \"Cross happened?\", \"X\", location.top) // 会在发生处显示 X\n\n// 方法 2: 日志调试\nif cross\n    // 只有发生交叉时才打印\n    // str.format 类似 Python 的 f-string 或 .format\n    msg = str.format(\"Gold Cross at bar {0}. Price: {1}\", bar_index, close)\n    log.info(msg)\nelse if barstate.islast\n    log.info(\"Current Close: \" + str.tostring(close))",
      "python_code": "# Python\nimport logging\n\n# 配置日志\nlogging.basicConfig(level=logging.INFO)\n\nif crossover:\n    # f-string 调试\n    logging.info(f\"Gold Cross at index {i}. Price: {close}\")\n    print(f\"DEBUG: Fast={fast_val}, Slow={slow_val}\")",
      "quiz": [
        {
          "q": "在 Pine Script 中如何将数字转换为字符串以进行日志打印？",
          "choices": [
            {
              "text": "str(123)",
              "isCorrect": false
            },
            {
              "text": "str.tostring(123)",
              "isCorrect": true
            },
            {
              "text": "string(123)",
              "isCorrect": false
            }
          ],
          "explain": "Pine 使用 str.tostring() 进行类型转换。"
        },
        {
          "q": "log.error() 的输出通常显示在哪里？",
          "choices": [
            {
              "text": "图表上",
              "isCorrect": false
            },
            {
              "text": "Pine Editor 下方的 Pine Logs 面板",
              "isCorrect": true
            },
            {
              "text": "浏览器控制台",
              "isCorrect": false
            }
          ],
          "explain": "需要在编辑器下方切换到 'Pine Logs' 标签页查看。"
        },
        {
          "q": "plotchar 的作用是？",
          "choices": [
            {
              "text": "绘制字符标记，且其值会显示在数据窗口",
              "isCorrect": true
            },
            {
              "text": "画线",
              "isCorrect": false
            }
          ],
          "explain": "plotchar 不仅能在图上打标，其 title 和 value 也会出现在 Data Window 中，适合调试布尔值或状态。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l5_functions",
      "title": "9. 自定义函数",
      "subtitle": "单行与多行函数",
      "concept": "<h3>为什么要写函数？</h3>\n<p>函数的价值是把“可复用的计算步骤”封装起来：让策略逻辑更短、更清晰，也更容易做参数化与复用。</p>\n<div class=\"detail-box\">\n  <h4>1) 基本语法</h4>\n  <ul>\n    <li><b>单行函数:</b> <code>f(x) => x * 2</code></li>\n    <li><b>多行函数:</b> 函数体需要缩进，最后一行表达式会自动作为返回值。</li>\n  </ul>\n</div>\n<h3>2) 类型与输入 / 输出（写得“像工程”）</h3>\n<ul>\n  <li><b>输入:</b> 传入一个或多个 series（src、length、阈值等）。建议显式写参数类型（float/int/bool），减少隐式转换错误。</li>\n  <li><b>输出:</b> 返回 series（供 plot/信号判断）或返回元组（Tuple）用于多返回值。</li>\n</ul>\n<h3>3) 多返回值（Tuple）</h3>\n<p>当你想一次返回多条序列时，用元组最清晰：<code>[a, b] = f()</code>。</p>\n<h3>边界与性能注意事项</h3>\n<ul>\n  <li><b>不要写递归:</b> Pine 不支持递归（也不适合逐 bar 递归）。</li>\n  <li><b>避免在函数里手写大循环:</b> 每根 K 线都会调用函数，循环放大后很容易变慢。</li>\n  <li><b>绘图/交易指令的作用域:</b> 绘图与下单更建议保持在主逻辑层，函数专注于“计算并返回结果”。</li>\n</ul>\n<h3>实战建议（函数是把复杂度关进盒子里）</h3>\n<ul>\n  <li><b>把重复逻辑封装:</b> 信号判定、风控距离、显示文本格式化等。</li>\n  <li><b>返回值尽量单一:</b> 需要多个结果时用元组返回，并在调用处拆包。</li>\n  <li><b>明确输入/输出:</b> 输入用参数传递，减少隐式依赖，降低调试成本。</li>\n</ul>\n<h3>边界条件</h3>\n<ul>\n  <li><b>na 传播:</b> 函数内部可能返回 <code>na</code>，调用者要负责兜底处理。</li>\n  <li><b>性能:</b> 在函数里创建大量对象（label/line）会很慢，尽量只在必要时创建。</li>\n</ul>\n<h3>进阶补充：函数式编程思维</h3>\n<h4>1. 多返回值 (Tuple)</h4>\n<p>Pine Script 函数支持一次返回多个值，这在计算复杂指标（如 MACD 返回快线、慢线、柱体）时非常有用。</p>\n<pre><code>calc_macd(src, fast, slow) =>\n    fast_ma = ta.ema(src, fast)\n    slow_ma = ta.ema(src, slow)\n    [fast_ma, slow_ma] // 返回元组\n\n[f, s] = calc_macd(close, 12, 26)\n</code></pre>\n<h4>2. 单行函数 vs 多行函数</h4>\n<ul>\n  <li><b>单行:</b> <code>f(x) => x * 2</code> 简洁，适合简单计算。</li>\n  <li><b>多行:</b> 必须缩进，适合复杂逻辑。最后一行表达式的值会自动作为返回值（无需 return 关键字）。</li>\n</ul>\n<h4>3. 作用域陷阱</h4>\n<p>函数内部可以读取外部的全局变量，但<b>不能修改</b>外部的全局变量（除非用 <code>:=</code> 修改且该变量已在外部声明）。最佳实践是尽量保持函数“纯粹”，只依赖参数输入。</p>",
      "summary": [
        "=> 用于定义函数，多行函数依赖缩进",
        "函数自动返回最后一行表达式结果",
        "建议显式参数类型，减少类型不匹配",
        "支持元组多返回值：[a, b] = f()",
        "函数尽量只做计算，避免重循环导致变慢",
        "把边界条件写进逻辑里：na、对象上限、确认时机"
      ],
      "pine_code": "//@version=5\nindicator(\"Functions\")\n\n// 单行函数\nf_avg(x, y) => (x + y) / 2\n\n// 多行函数\nf_custom_ma(src, length) =>\n    sum = 0.0\n    for i = 0 to length - 1\n        sum := sum + src[i]\n    sum / length // 返回值\n\nplot(f_custom_ma(close, 14))",
      "python_code": "# Python\ndef f_avg(x, y):\n    return (x + y) / 2\n\ndef f_custom_ma(series, length):\n    # 向量化操作优于循环\n    return series.rolling(length).mean()",
      "quiz": [
        {
          "q": "Pine Script 中定义函数的符号是什么？",
          "choices": [
            {
              "text": "def",
              "isCorrect": false
            },
            {
              "text": "function",
              "isCorrect": false
            },
            {
              "text": "=>",
              "isCorrect": true
            }
          ],
          "explain": "Pine 使用箭头符号 => 来定义函数。"
        },
        {
          "q": "多行函数的返回值是？",
          "choices": [
            {
              "text": "第一行的结果",
              "isCorrect": false
            },
            {
              "text": "最后一行表达式的结果",
              "isCorrect": true
            },
            {
              "text": "必须使用 return 关键字",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 函数自动返回最后一行表达式的值，不需要显式 return。"
        },
        {
          "q": "函数可以修改外部的全局变量吗？",
          "choices": [
            {
              "text": "可以",
              "isCorrect": false
            },
            {
              "text": "不可以 (除非使用 array 等引用类型)",
              "isCorrect": true
            }
          ],
          "explain": "Pine 函数是纯函数式的，不能直接修改外部的基础类型变量，但可以修改 array/matrix 内容。"
        },
        {
          "q": "如何从函数返回两个值？",
          "choices": [
            {
              "text": "return a, b",
              "isCorrect": false
            },
            {
              "text": "[a, b]",
              "isCorrect": true
            },
            {
              "text": "a and b",
              "isCorrect": false
            }
          ],
          "explain": "Pine 支持元组返回，语法是 [res1, res2] = func()。"
        },
        {
          "q": "Python 中定义函数使用什么关键字？",
          "choices": [
            {
              "text": "func",
              "isCorrect": false
            },
            {
              "text": "def",
              "isCorrect": true
            },
            {
              "text": "function",
              "isCorrect": false
            }
          ],
          "explain": "Python 使用 def 关键字。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l10_arrays",
      "title": "10. 数组 (Arrays)",
      "subtitle": "处理非序列数据的动态集合",
      "concept": "<h3>为什么 Pine 还需要数组？</h3>\n<p>虽然 Pine 的普通变量天然就是时间序列（series），但有些需求并不是“每根 K 线一个值”的形式，例如：维护一个可变长度的列表、做排序/去重、保存若干个关键价位、做队列/栈。此时就需要 <code>array</code>。</p>\n<div class=\"detail-box\">\n  <h4>常用 API（最常用的一组）</h4>\n  <ul>\n    <li><code>array.new_float(size)</code>: 创建数组（强类型：float/int/bool/string）。</li>\n    <li><code>array.push(id, value)</code>: 末尾追加。</li>\n    <li><code>array.pop(id)</code>: 弹出末尾元素。</li>\n    <li><code>array.get(id, index)</code> / <code>array.set(id, index, value)</code>: 读写指定位置。</li>\n    <li><code>array.size(id)</code>: 当前长度。</li>\n  </ul>\n</div>\n<h3>输入 / 输出与边界条件</h3>\n<ul>\n  <li><b>输入:</b> 你想保存的离散数据（价格、bar_index、信号发生点等）。</li>\n  <li><b>输出:</b> 从数组取出来的值（通常用于画线/打标或进一步计算）。</li>\n  <li><b>边界:</b> 数组索引从 0 开始；越界访问会报错，务必先检查 <code>array.size()</code>。</li>\n  <li><b>性能:</b> 数组通常用 <code>var</code> 初始化一次；在实时 bar 内频繁 push 可能导致性能下降。</li>\n</ul>\n<h3>进阶补充：数组的高级应用</h3>\n<h4>1. 动态数组 vs 历史序列</h4>\n<p>这是新手最大的困惑：<code>close</code> 是历史序列，自动维护历史；<code>array</code> 是你手动维护的容器。你可以在一根 K 线上往 array 里塞入 100 个 tick 的价格，这是 series 做不到的。</p>\n<h4>2. 队列与栈 (Queue & Stack)</h4>\n<p>数组常被用来实现 FIFO（先进先出）队列，例如计算最近 10 次金叉的平均间隔：</p>\n<pre><code>// 维护一个固定长度的数组\nif condition\n    array.push(myArray, bar_index)\n    if array.size(myArray) > 10\n        array.shift(myArray) // 移除最早的一个\n</code></pre>\n<h4>3. 性能警告</h4>\n<p>不要在每根 K 线上都 <code>array.new_float(0)</code>！这会创建数万个对象。一定要用 <code>var a = array.new_float(0)</code>，然后用 <code>array.clear(a)</code> 在需要时清空它。</p>",
      "summary": [
        "数组用于保存“非时间序列”的动态集合",
        "数组索引从 0 开始，越界会报错",
        "必须用 array.get/set 读写，不能用 []",
        "[] 专用于时间序列历史引用",
        "数组一般用 var 初始化，避免每根 K 线重建"
      ],
      "pine_code": "//@version=5\nindicator(\"Arrays\")\n\n// 仅在第一根 K 线初始化\nvar a = array.new_float(0)\n\nif close > open\n    array.push(a, close)\n\n// 获取最后一个存入的值\nlast_val = array.size(a) > 0 ? array.get(a, array.size(a) - 1) : na\nplot(last_val)",
      "python_code": "# Python (Standard List)\nmy_list = []\n\n# 在循环中\nif close > open:\n    my_list.append(close)\n\nlast_val = my_list[-1] if len(my_list) > 0 else None",
      "quiz": [
        {
          "q": "在 Pine Script 中如何读取数组 a 的第一个元素？",
          "choices": [
            {
              "text": "a[0]",
              "isCorrect": false
            },
            {
              "text": "array.get(a, 0)",
              "isCorrect": true
            },
            {
              "text": "a.first()",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 的数组必须通过 array.get() 函数访问，[] 操作符被保留用于历史数据引用。"
        },
        {
          "q": "如何向数组末尾添加元素？",
          "choices": [
            {
              "text": "array.add()",
              "isCorrect": false
            },
            {
              "text": "array.push()",
              "isCorrect": true
            },
            {
              "text": "array.append()",
              "isCorrect": false
            }
          ],
          "explain": "使用 array.push(id, value)。"
        },
        {
          "q": "array.new_float(0) 的含义是？",
          "choices": [
            {
              "text": "创建一个包含 0 的数组",
              "isCorrect": false
            },
            {
              "text": "创建一个初始大小为 0 的浮点数数组",
              "isCorrect": true
            }
          ],
          "explain": "参数是初始大小。"
        },
        {
          "q": "Pine 数组与 Python List 的主要区别？",
          "choices": [
            {
              "text": "Pine 数组不能存储不同类型的数据",
              "isCorrect": true
            },
            {
              "text": "Python List 不能动态扩容",
              "isCorrect": false
            }
          ],
          "explain": "Pine 数组是强类型的 (int array, float array)，Python List 可以混合类型。"
        },
        {
          "q": "数组通常配合什么关键字初始化？",
          "choices": [
            {
              "text": "var",
              "isCorrect": true
            },
            {
              "text": "const",
              "isCorrect": false
            }
          ],
          "explain": "通常使用 var 关键字，确保数组只被创建一次，而不是每根 K 线都重新创建。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l13_maps",
      "title": "11. 映射 (Maps)",
      "subtitle": "Key-Value 键值对集合",
      "concept": "<h3>什么是 Map?</h3>\n<p>Pine Script v5 引入了 <code>map</code> 类型，允许存储 <b>Key-Value (键-值)</b> 对。这在需要关联数据时非常有用（例如：统计每个价格出现的次数，或者存储不同 Symbol 的配置）。</p>\n<div class=\"detail-box\">\n    <h4>核心操作</h4>\n    <ul>\n        <li><code>m = map.new<key_type, val_type>()</code>: 创建新 Map。</li>\n        <li><code>map.put(m, key, value)</code>: 存入或更新数据。</li>\n        <li><code>map.get(m, key)</code>: 读取数据。</li>\n        <li><code>map.contains(m, key)</code>: 检查键是否存在。</li>\n        <li><code>map.remove(m, key)</code>: 删除键。</li>\n    </ul>\n</div>\n<p><b>注意:</b> Map 是引用类型，修改 Map 会影响所有引用它的变量。</p>\n<h3>典型用法（把 Map 当成轻量字典）</h3>\n<ul>\n  <li><b>参数表:</b> 用键名（如品种/周期）映射到参数组，避免一堆 if/else。</li>\n  <li><b>状态缓存:</b> 记录事件最后一次发生的 bar_index 或价格，便于后续计算。</li>\n</ul>\n<h3>边界与注意</h3>\n<ul>\n  <li><b>键不存在:</b> 取值前先 <code>map.contains()</code> 或设置默认值，避免逻辑断裂。</li>\n  <li><b>类型一致:</b> Map 的 key/value 类型要一致，建议用命名约束语义。</li>\n</ul>\n<h3>进阶补充：数据结构详解</h3>\n<h4>1. 引用类型（Reference Types）</h4>\n<p>Array 和 Map 是<b>引用类型</b>。当你把一个数组赋值给另一个变量时，你只是复制了“指针”。修改新变量也会影响原数组。</p>\n<pre><code>a = array.from(1, 2)\nb = a\narray.push(b, 3)\n// 此时 a 也会变成 [1, 2, 3]\n</code></pre>\n<h4>2. 性能考量</h4>\n<ul>\n  <li><b>Map vs Array:</b> Map 的查找速度通常比遍历 Array 快，但创建开销大。</li>\n  <li><b>持久化：</b> 务必使用 <code>var</code> 关键字声明 Array/Map，否则每根 K 线都会重新创建空对象，极其消耗性能且逻辑通常是错的。</li>\n</ul>\n<pre><code>// 正确做法\nvar a = array.new_float(0)\narray.push(a, close)\n</code></pre>\n<h4>3. 常用操作</h4>\n<ul>\n  <li><code>array.sort()</code>: 排序。</li>\n  <li><code>array.avg()</code> / <code>array.stdev()</code>: 对数组内容进行统计计算。</li>\n  <li><code>map.put(key, value)</code> / <code>map.get(key)</code>: 键值对存取。</li>\n</ul>",
      "summary": [
        "Map 用于存储键值对",
        "必须指定 Key 和 Value 的类型",
        "比 Array 查找速度更快（哈希表）",
        "map.get 取不到 key 会返回 na，最好先 contains 或用 nz 兜底",
        "Map 通常用 var 初始化一次，避免频繁重建",
        "把边界条件写进逻辑里：na、对象上限、确认时机"
      ],
      "pine_code": "//@version=5\nindicator(\"Map Demo\")\n\n// 创建一个 Map: Key是价格(float), Value是次数(int)\n// 用于统计价格分布 (Market Profile 简易版)\nvar price_map = map.new<float, int>()\n\n// 将价格取整到最近的 10 美元\nlevel = math.round(close / 10) * 10\n\n// 更新计数\nif barstate.isnew // 实时bar只计算一次\n    int count = 0\n    if map.contains(price_map, level)\n        count := map.get(price_map, level)\n    \n    map.put(price_map, level, count + 1)\n\n// 在最后一根K线打印统计结果\nif barstate.islast\n    keys = map.keys(price_map)\n    size = array.size(keys)\n    if size > 0\n        log.info(\"Total price levels tracked: \" + str.tostring(size))\n        // 获取某个价格的出现次数\n        demo_level = array.get(keys, 0)\n        log.info(\"Level \" + str.tostring(demo_level) + \" count: \" + str.tostring(map.get(price_map, demo_level)))",
      "python_code": "# Python (Dictionary)\nprice_map = {}\n\nlevel = round(close / 10) * 10\n\nif level in price_map:\n    price_map[level] += 1\nelse:\n    price_map[level] = 1\n\nprint(f\"Level {level} count: {price_map[level]}\")",
      "quiz": [
        {
          "q": "Python 的 Dictionary (字典) 对应 Pine Script 的什么结构？",
          "choices": [
            {
              "text": "Array",
              "isCorrect": false
            },
            {
              "text": "Map",
              "isCorrect": true
            },
            {
              "text": "Matrix",
              "isCorrect": false
            }
          ],
          "explain": "Map 和 Dictionary 都是基于键值对 (Key-Value) 的哈希结构。"
        },
        {
          "q": "如何向 map m 中存入键值对 'A': 1？",
          "choices": [
            {
              "text": "m['A'] = 1",
              "isCorrect": false
            },
            {
              "text": "map.put(m, 'A', 1)",
              "isCorrect": true
            },
            {
              "text": "map.add(m, 'A', 1)",
              "isCorrect": false
            }
          ],
          "explain": "Pine Script 使用 map.put() 方法。"
        },
        {
          "q": "如果 map.get(m, key) 中的 key 不存在，会返回什么？",
          "choices": [
            {
              "text": "0",
              "isCorrect": false
            },
            {
              "text": "na (空值)",
              "isCorrect": true
            },
            {
              "text": "报错停止运行",
              "isCorrect": false
            }
          ],
          "explain": "返回 na，所以通常需要配合 map.contains() 或 nz() 使用。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "l14_libraries",
      "title": "12. 库 (Libraries)",
      "subtitle": "代码模块化与复用",
      "concept": "<h3>库的作用：把“计算逻辑”变成可复用模块</h3>\n<p>当脚本越来越长，或者你想在多个指标/策略里复用同一套计算（例如自定义均线、风控工具、信号过滤器），就应该把它提炼成 <b>Library</b>。库的核心定位是：<b>只做计算，返回结果</b>。</p>\n<div class=\"detail-box\">\n  <h4>输入 / 输出</h4>\n  <ul>\n    <li><b>输入:</b> 传入 series（src、high/low/close 等）与参数（length、factor）。</li>\n    <li><b>输出:</b> 返回计算后的 series 或元组（供外部脚本 plot 或用于下单判断）。</li>\n  </ul>\n</div>\n<h4>1) 创建库</h4>\n<p>脚本开头声明 <code>library(\"LibName\")</code>，并使用 <code>export</code> 导出可被外部调用的函数（建议显式写参数类型）。</p>\n<pre><code>//@version=5\nlibrary(\"MyTools\", overlay=true)\n\nexport my_sma(float src, int len) =>\n    ta.sma(src, len)</code></pre>\n<h4>2) 使用库</h4>\n<p>在其他脚本中用 <code>import</code> 导入（格式：用户名/库名/版本），再通过别名调用导出函数。</p>\n<pre><code>//@version=5\nindicator(\"Test Lib\")\nimport username/MyTools/1 as mt\n\nplot(mt.my_sma(close, 14))</code></pre>\n<h3>边界与注意事项</h3>\n<ul>\n  <li><b>库里不要写绘图/下单:</b> 库更适合做“纯计算”，把 plot/strategy 放在调用方脚本里。</li>\n  <li><b>版本管理:</b> 发布库后用版本号升级，避免改动导致旧脚本行为变化。</li>\n  <li><b>安全:</b> 不要在库里硬编码任何敏感信息（即使是“私有脚本”，也可能被复制）。</li>\n</ul>\n<h3>进阶补充：库的发布与管理</h3>\n<h4>1. export 关键字</h4>\n<p>只有加上 <code>export</code> 关键字的函数才能被外部脚本调用。未导出的函数只能在库内部使用（私有函数）。</p>\n<pre><code>// @version=5\nlibrary(\"MyLib\")\n\nexport myFunc(int x) => x * 2\n</code></pre>\n<h4>2. 类型系统限制</h4>\n<p>库函数的参数和返回值必须有明确的类型签名。你不能写一个参数类型模糊的库函数，这要求你对 Pine 的类型系统（series float vs simple int）有更深的理解。</p>\n<h4>3. 引用库</h4>\n<p>使用 <code>import Username/LibName/Version as alias</code> 导入。TradingView 社区有大量现成的标准库（如 `Ta-Lib` 实现）可供直接调用。</p>",
      "summary": [
        "使用 library() 声明库脚本",
        "使用 export 关键字导出函数",
        "使用 import 导入库，格式为 用户名/库名/版本",
        "库函数不能绘图 (plot)，只能返回计算结果",
        "库适合沉淀信号/风控/工具函数，调用方负责展示与交易"
      ],
      "pine_code": "// --- 文件 1: 库 (MyMath) ---\n//@version=5\n// 库脚本不能直接画图\nlibrary(\"MyMath\", overlay = true)\n\n// 导出一个计算复利增长的函数\n// 必须明确指定参数类型\nexport compound_interest(float principal, float rate, int periods) =>\n    principal * math.pow(1 + rate, periods)\n\n// --- 文件 2: 指标 (使用库) ---\n//@version=5\nindicator(\"Lib Usage\")\n// 假设这是你发布的库，版本为 1\n// import YourName/MyMath/1 as mm\n\n// res = mm.compound_interest(1000, 0.05, 10)\n// plot(res)",
      "python_code": "# Python (Modules)\n# file: my_math.py\ndef compound_interest(principal, rate, periods):\n    return principal * (1 + rate) ** periods\n\n# file: main.py\nimport my_math as mm\n\nres = mm.compound_interest(1000, 0.05, 10)\nprint(res)",
      "quiz": [
        {
          "q": "库脚本以什么声明开头？",
          "choices": [
            {
              "text": "indicator()",
              "isCorrect": false
            },
            {
              "text": "library()",
              "isCorrect": true
            },
            {
              "text": "strategy()",
              "isCorrect": false
            }
          ],
          "explain": "库必须使用 library() 声明。"
        },
        {
          "q": "库中的函数如果想被外部调用，必须加什么关键字？",
          "choices": [
            {
              "text": "public",
              "isCorrect": false
            },
            {
              "text": "export",
              "isCorrect": true
            },
            {
              "text": "global",
              "isCorrect": false
            }
          ],
          "explain": "使用 export 导出函数，未导出的函数仅为库内部私有。"
        },
        {
          "q": "库函数可以直接 plot() 画图吗？",
          "choices": [
            {
              "text": "可以",
              "isCorrect": false
            },
            {
              "text": "不可以",
              "isCorrect": true
            }
          ],
          "explain": "库主要用于计算逻辑复用，不能直接包含 plot, strategy.entry 等绘图或交易指令。"
        }
      ],
      "category": "基础语法 (Basics)"
    },
    {
      "id": "ind_macd",
      "title": "指标 1: MACD (异同移动平均线)",
      "subtitle": "趋势跟踪与动量指标之王",
      "concept": "<h3>核心思路</h3>\n<p>MACD 用两条不同速度的 EMA 之间的差值来描述<b>动量变化</b>：动量增强时差值扩大，动量衰减时差值收敛。</p>\n<div class=\"detail-box\">\n    <h4>1) 组成与公式</h4>\n    <p><b>DIF（快线）:</b> <code>EMA(Close, fast) - EMA(Close, slow)</code></p>\n    <p><b>DEA（慢线/信号线）:</b> <code>EMA(DIF, signal)</code></p>\n    <p><b>Hist（柱）:</b> <code>DIF - DEA</code>（不同软件可能做缩放，但方向一致）</p>\n</div>\n<h4>2) 三类常用信号（建议按优先级使用）</h4>\n<ul>\n    <li><b>交叉信号（最基础）:</b> DIF 上穿 DEA 为金叉；下穿为死叉。实盘里尽量用<b>收盘确认</b>，避免盘中来回穿越导致“假信号”。</li>\n    <li><b>零轴信号（更稳）:</b> DIF/DEA 在 0 轴上方偏多头环境；0 轴下方偏空头环境。很多策略会要求“金叉 + 位于 0 轴上方”才做多。</li>\n    <li><b>背离信号（更进阶）:</b> 价格创新高但 DIF/Hist 不创新高是顶背离；价格创新低但 DIF/Hist 不创新低是底背离。背离更像“概率提示”，不是立刻反转的保证。</li>\n</ul>\n<h4>3) 参数怎么调（不靠拍脑袋）</h4>\n<ul>\n    <li><b>fast/slow 越小:</b> 更灵敏，信号更多但噪音更大；越大则更稳但更滞后。</li>\n    <li><b>signal 越小:</b> DEA 更贴近 DIF，交叉更频繁；越大则更平滑。</li>\n    <li><b>建议方法:</b> 先确定交易周期（如 1H/4H/D），再用历史样本做“分段验证”，并把手续费/滑点纳入回测。</li>\n</ul>\n<h4>4) 组合用法（把相关性用起来）</h4>\n<ul>\n    <li><b>趋势过滤:</b> 用 ADX（例如 ADX>25）筛掉震荡期，避免 MACD 频繁交叉。</li>\n    <li><b>波动管理:</b> 用 ATR 设止损/移动止损，让“信号”与“风险”绑定。</li>\n</ul>\n<h4>Pine Script 快速实现</h4>\n<p><code>ta.macd(source, fast, slow, signal)</code> 直接返回 <code>[macdLine, signalLine, histLine]</code>，适合把 DIF/DEA/Hist 分开画出来做诊断。</p>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> price source（常用 close）、fast/slow/signal 三个周期。</li><li><b>输出:</b> DIF、DEA、Hist（柱）。建议三条线都画出来做诊断。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>fast/slow:</b> 负责动量对比的时间尺度，差距越大越稳但更滞后。</li><li><b>signal:</b> 决定 DEA 的平滑程度，过小交叉频繁、过大反应变慢。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.macd(source, fast, slow, signal) 返回 DIF/DEA/Hist",
        "交叉=基础信号，零轴=环境过滤，背离=进阶提示",
        "fast/slow 控制灵敏度，signal 控制平滑程度",
        "实盘优先用收盘确认，避免盘中假穿越",
        "常用 ADX/ATR 做过滤与风控联动",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"MACD Example\")\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplot(macdLine, color=color.blue)\nplot(signalLine, color=color.orange)\nplot(histLine, style=plot.style_histogram)",
      "python_code": "# Python (Backtrader)\nclass MACDStrategy(bt.Strategy):\n    def __init__(self):\n        self.macd = bt.indicators.MACD(self.data, \n                                       period_me1=12, \n                                       period_me2=26, \n                                       period_signal=9)\n    def next(self):\n        # self.macd.macd (DIF)\n        # self.macd.signal (DEA)\n        pass",
      "quiz": [
        {
          "q": "MACD 的快线通常是哪两条均线的差？",
          "choices": [
            {
              "text": "EMA12 - EMA26",
              "isCorrect": true
            },
            {
              "text": "SMA12 - SMA26",
              "isCorrect": false
            },
            {
              "text": "EMA5 - EMA10",
              "isCorrect": false
            }
          ],
          "explain": "标准 MACD 使用 12 和 26 周期的 EMA。"
        },
        {
          "q": "ta.macd 函数返回几个值？",
          "choices": [
            {
              "text": "1个",
              "isCorrect": false
            },
            {
              "text": "3个 (MACD线, 信号线, 柱状图)",
              "isCorrect": true
            }
          ],
          "explain": "返回元组 [macdLine, signalLine, histLine]。"
        },
        {
          "q": "Backtrader 的 MACD 指标包含柱状图吗？",
          "choices": [
            {
              "text": "包含 (macd.histo)",
              "isCorrect": true
            },
            {
              "text": "不包含",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 的 MACD 指标对象包含 macd, signal, histo 三条线。"
        },
        {
          "q": "当 MACD 柱状图由负转正，意味着？",
          "choices": [
            {
              "text": "DIF 上穿 DEA (金叉)",
              "isCorrect": true
            },
            {
              "text": "DIF 下穿 DEA (死叉)",
              "isCorrect": false
            }
          ],
          "explain": "柱状图 = DIF - DEA，由负转正说明 DIF 变得大于 DEA。"
        },
        {
          "q": "MACD 属于哪类指标？",
          "choices": [
            {
              "text": "震荡指标",
              "isCorrect": true
            },
            {
              "text": "成交量指标",
              "isCorrect": false
            }
          ],
          "explain": "MACD 兼具趋势跟踪和震荡特性，通常归类为震荡指标。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_rsi",
      "title": "指标 2: RSI (相对强弱指数)",
      "subtitle": "超买超卖的经典判断",
      "concept": "<h3>核心思路</h3>\n<p>RSI 衡量的是“上涨力度”和“下跌力度”的相对关系。它不是预测器，而是<b>状态刻度尺</b>：告诉你当前更偏多方还是空方占优。</p>\n<div class=\"detail-box\">\n    <h4>1) 计算逻辑（你需要记住的重点）</h4>\n    <p><code>RSI = 100 - 100 / (1 + RS)</code></p>\n    <p><b>RS</b> = 平均上涨幅度 / 平均下跌幅度。Pine 的 <code>ta.rsi</code> 使用 <code>ta.rma</code>（Wilder 平滑），所以它比“简单平均”更平滑、更贴近标准定义。</p>\n</div>\n<h4>2) 三套用法（按稳定性排序）</h4>\n<ul>\n    <li><b>中轴法（更适合趋势）:</b> RSI>50 偏多，RSI<50 偏空。很多趋势系统用它做“是否允许做多/做空”的过滤。</li>\n    <li><b>阈值法（最常见）:</b> 70/30 或 80/20。注意：在强趋势里 RSI 会“钝化”（长时间超买/超卖），此时逆势容易接飞刀。</li>\n    <li><b>背离法（更进阶）:</b> 价格创新高但 RSI 不创新高（顶背离）；价格创新低但 RSI 不创新低（底背离）。背离需要结合结构位/趋势环境确认。</li>\n</ul>\n<h4>3) 参数怎么调</h4>\n<ul>\n    <li><b>length 越短:</b> 更敏感，适合短线但噪音大；越长更稳，适合中长线。</li>\n    <li><b>阈值不必死守 70/30:</b> 强趋势品种可用 80/40（多头偏置），弱势品种可用 60/20（空头偏置）。</li>\n</ul>\n<h4>4) 与其他指标的联动（让逻辑更闭环）</h4>\n<ul>\n    <li><b>用趋势过滤“钝化陷阱”:</b> 例如“价格在长期均线之上才做 RSI 回归”，或“ADX 低时才做均值回归”。</li>\n    <li><b>用波动管理止损:</b> ATR/布林带带宽用于确定止损距离，避免用固定点数导致不同品种风险不一致。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> source 与 length（常用 close, 14）。</li><li><b>输出:</b> 0~100 的强弱刻度（更像状态仪表，而不是指令）。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>length:</b> 越短越敏感，越长越稳；要结合交易周期与品种特性验证。</li><li><b>阈值:</b> 70/30 只是起点，可用 80/40 或 60/20 做多空偏置。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.rsi(source, length) 内部用 ta.rma 平滑",
        "中轴法更适合趋势；阈值法更直观但易钝化",
        "背离是概率提示，需要环境过滤与结构确认",
        "length 越短越敏感，越长越稳但更滞后",
        "常配合 MA/ADX 过滤与 ATR 做风控",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"RSI Example\")\nr = ta.rsi(close, 14)\nplot(r)\nhline(70, color=color.red)\nhline(30, color=color.green)",
      "python_code": "# Python (Backtrader)\nclass RSIStrategy(bt.Strategy):\n    def __init__(self):\n        self.rsi = bt.indicators.RSI(self.data, period=14)\n        \n    def next(self):\n        if self.rsi[0] > 70:\n            # Overbought\n            pass",
      "quiz": [
        {
          "q": "RSI 的标准周期通常是多少？",
          "choices": [
            {
              "text": "14",
              "isCorrect": true
            },
            {
              "text": "5",
              "isCorrect": false
            },
            {
              "text": "20",
              "isCorrect": false
            }
          ],
          "explain": "Wilder 提出的标准 RSI 周期为 14。"
        },
        {
          "q": "RSI 大于 70 通常被认为是什么信号？",
          "choices": [
            {
              "text": "超买",
              "isCorrect": true
            },
            {
              "text": "超卖",
              "isCorrect": false
            }
          ],
          "explain": "超过 70 视为市场过热（超买），低于 30 视为过冷（超卖）。"
        },
        {
          "q": "ta.rsi 的返回值范围是？",
          "choices": [
            {
              "text": "0 到 100",
              "isCorrect": true
            },
            {
              "text": "-100 到 100",
              "isCorrect": false
            },
            {
              "text": "无限制",
              "isCorrect": false
            }
          ],
          "explain": "RSI 是归一化指标，永远在 0-100 之间。"
        },
        {
          "q": "Backtrader 的 RSI 默认使用什么类型的移动平均？",
          "choices": [
            {
              "text": "Wilder's MA (SMMA)",
              "isCorrect": true
            },
            {
              "text": "SMA",
              "isCorrect": false
            }
          ],
          "explain": "标准 RSI 计算使用 Wilder 平滑，Backtrader 遵循此标准。"
        },
        {
          "q": "RSI 背离是指？",
          "choices": [
            {
              "text": "价格创新高但 RSI 未创新高",
              "isCorrect": true
            },
            {
              "text": "价格和 RSI 同时创新高",
              "isCorrect": false
            }
          ],
          "explain": "顶背离（看跌）：价格新高，RSI 未新高；底背离（看涨）：价格新低，RSI 未新低。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_bb",
      "title": "指标 3: Bollinger Bands (布林带)",
      "subtitle": "波动率通道与均值回归",
      "concept": "<h3>核心思路</h3>\n<p>布林带把“均值”和“波动率”同时画在图上：中轨是均值，上下轨是均值 ± N 倍标准差。它真正的价值在于：<b>用带宽变化观察波动率的收缩与扩张</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 组成与公式</h4>\n    <p><b>Middle:</b> <code>SMA(series, length)</code></p>\n    <p><b>Upper:</b> <code>Middle + mult * Stdev(series, length)</code></p>\n    <p><b>Lower:</b> <code>Middle - mult * Stdev(series, length)</code></p>\n    <p><code>ta.bb(series, length, mult)</code> 返回 <code>[middle, upper, lower]</code></p>\n</div>\n<h4>2) 两种完全不同的交易视角（别混用）</h4>\n<ul>\n    <li><b>均值回归视角:</b> 把上下轨当作“偏离过度”的边界，触及下轨/上轨后寻找回归中轨的机会。适合震荡环境。</li>\n    <li><b>趋势跟随视角:</b> 把“突破上轨/下轨”当作波动率扩张与趋势启动信号。适合趋势环境。</li>\n</ul>\n<h4>3) 带宽、%B 与 Squeeze（进阶但很实用）</h4>\n<ul>\n    <li><b>带宽 Bandwidth:</b> <code>(Upper - Lower) / Middle</code>，衡量波动率强弱。</li>\n    <li><b>%B:</b> <code>(Price - Lower) / (Upper - Lower)</code>，量化价格在通道里的相对位置。</li>\n    <li><b>Squeeze:</b> 带宽长时间极低，往往意味着“积蓄能量”，随后可能爆发行情；但方向需要额外确认。</li>\n</ul>\n<h4>4) 参数怎么调</h4>\n<ul>\n    <li><b>length:</b> 越大越平滑，越小越敏感。日内可偏小，日线偏大更稳。</li>\n    <li><b>mult:</b> 越大越“宽”，触轨更少但更可靠；越小更“窄”，信号更多但更容易假突破。</li>\n</ul>\n<h4>5) 常见坑</h4>\n<ul>\n    <li><b>上轨不是天然阻力，下轨不是天然支撑:</b> 强趋势里经常沿轨运行（你看到的“超买/超卖”可能只是趋势很强）。</li>\n    <li><b>先定环境再定策略:</b> 用 ADX/均线斜率判断是趋势还是震荡，再选择突破或回归逻辑。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> series、length、mult。</li><li><b>输出:</b> middle/upper/lower 三条通道线，以及衍生的带宽、%B。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>length:</b> 决定均值的平滑程度。</li><li><b>mult:</b> 决定通道宽度，越大越稳但触发更少。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.bb(series, length, mult) 返回中/上/下轨",
        "均值回归与突破跟随是两套不同逻辑",
        "带宽描述波动率，Squeeze 常是变盘前兆",
        "mult 越大越稳但信号更少，越小越敏感",
        "强趋势会沿轨运行，先判断环境再交易",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"Bollinger Bands\")\n[middle, upper, lower] = ta.bb(close, 20, 2)\nplot(upper, color=color.red)\nplot(lower, color=color.green)\nplot(middle, color=color.gray)",
      "python_code": "# Python (Backtrader)\nclass BBStrategy(bt.Strategy):\n    def __init__(self):\n        self.bb = bt.indicators.BollingerBands(self.data, period=20, devfactor=2.0)\n        \n    def next(self):\n        # self.bb.lines.top\n        # self.bb.lines.bot\n        # self.bb.lines.mid\n        pass",
      "quiz": [
        {
          "q": "布林带的中轨通常是什么？",
          "choices": [
            {
              "text": "20日 SMA",
              "isCorrect": true
            },
            {
              "text": "20日 EMA",
              "isCorrect": false
            },
            {
              "text": "VWAP",
              "isCorrect": false
            }
          ],
          "explain": "标准布林带中轨是简单移动平均线。"
        },
        {
          "q": "布林带上下轨的标准差倍数默认是？",
          "choices": [
            {
              "text": "2",
              "isCorrect": true
            },
            {
              "text": "1",
              "isCorrect": false
            },
            {
              "text": "3",
              "isCorrect": false
            }
          ],
          "explain": "默认使用 2 倍标准差，理论上包含约 95% 的价格数据。"
        },
        {
          "q": "ta.bb 函数返回几个值？",
          "choices": [
            {
              "text": "3个 (中, 上, 下)",
              "isCorrect": true
            },
            {
              "text": "2个 (上, 下)",
              "isCorrect": false
            }
          ],
          "explain": "返回 [middle, upper, lower]。"
        },
        {
          "q": "布林带收口 (Squeeze) 意味着什么？",
          "choices": [
            {
              "text": "波动率降低，即将变盘",
              "isCorrect": true
            },
            {
              "text": "趋势结束",
              "isCorrect": false
            }
          ],
          "explain": "带宽收窄表示市场进入低波动整理期，通常随后会出现剧烈突破。"
        },
        {
          "q": "Backtrader 的 BollingerBands 指标包含几条线？",
          "choices": [
            {
              "text": "3条 (top, bot, mid)",
              "isCorrect": true
            },
            {
              "text": "2条",
              "isCorrect": false
            }
          ],
          "explain": "包含 top, bot, mid 三条线。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_atr",
      "title": "指标 4: ATR (平均真实波幅)",
      "subtitle": "衡量市场波动率的尺子",
      "concept": "<h3>核心思路</h3>\n<p>ATR 衡量的是“最近一段时间，价格通常能走多远”。它不告诉你方向，只告诉你<b>波动有多大</b>，因此它非常适合做止损距离与仓位大小的统一度量。</p>\n<div class=\"detail-box\">\n    <h4>1) 真实波幅 TR（为什么叫 True）</h4>\n    <p>TR 取三者最大值，核心是把<b>跳空缺口</b>也算进去：</p>\n    <ul>\n        <li><code>High - Low</code></li>\n        <li><code>|High - Close[1]|</code></li>\n        <li><code>|Low - Close[1]|</code></li>\n    </ul>\n    <p><b>ATR:</b> <code>ATR = RMA(TR, length)</code>（标准是 Wilder 平滑）</p>\n</div>\n<h4>2) 两个高频用法</h4>\n<ul>\n    <li><b>止损/移动止损:</b> 用 <code>k * ATR</code> 作为止损距离，避免用固定点数导致不同品种风险不一致。</li>\n    <li><b>仓位规模:</b> 波动越大（ATR 越大），同样风险预算下仓位就应该越小（海龟 N 值思想）。</li>\n</ul>\n<h4>3) 让 ATR 可比（进阶）</h4>\n<ul>\n    <li><b>ATR 是“绝对值”:</b> 价格越高的品种 ATR 也会更大。若想跨品种比较，可用 <code>ATR% = ATR / close</code> 做归一化。</li>\n    <li><b>长度选择:</b> length 越短越敏感（止损更贴近，易被噪音打出）；越长越稳（止损更宽，回撤更大）。</li>\n</ul>\n<h4>4) 常见误区</h4>\n<ul>\n    <li><b>ATR 不是趋势指标:</b> ATR 上升可能是暴涨，也可能是暴跌；方向要用趋势指标或价格结构判断。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> length（常用 14）。</li><li><b>输出:</b> 波动强度（以价格单位计），常用于止损/仓位而不是定方向。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>length:</b> 越短越敏感、越长越平滑；建议结合历史分布校准阈值。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.atr(length) 衡量波动率，不判断方向",
        "TR 把跳空缺口纳入计算",
        "常用 k*ATR 做止损距离与仓位归一化",
        "跨品种可用 ATR% = ATR/close 做对比",
        "length 越短越贴近但易被噪音打出",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"ATR\")\nval = ta.atr(14)\nplot(val, color=color.purple)",
      "python_code": "# Python (Backtrader)\nclass ATRStrategy(bt.Strategy):\n    def __init__(self):\n        self.atr = bt.indicators.ATR(self.data, period=14)\n        \n    def next(self):\n        # 动态止损距离\n        stop_dist = self.atr[0] * 2",
      "quiz": [
        {
          "q": "ATR 衡量的是什么？",
          "choices": [
            {
              "text": "趋势方向",
              "isCorrect": false
            },
            {
              "text": "波动率 (Volatility)",
              "isCorrect": true
            },
            {
              "text": "成交量",
              "isCorrect": false
            }
          ],
          "explain": "ATR 专门用于衡量价格波动的剧烈程度，与方向无关。"
        },
        {
          "q": "真实波幅 (TR) 考虑了什么？",
          "choices": [
            {
              "text": "跳空缺口 (Gap)",
              "isCorrect": true
            },
            {
              "text": "只考虑当日高低差",
              "isCorrect": false
            }
          ],
          "explain": "TR = Max(High-Low, Abs(High-PrevClose), Abs(Low-PrevClose))，考虑了跳空情况。"
        },
        {
          "q": "海龟交易法中使用 N 值，N 值本质上是？",
          "choices": [
            {
              "text": "ATR",
              "isCorrect": true
            },
            {
              "text": "RSI",
              "isCorrect": false
            }
          ],
          "explain": "海龟法则中的 N 就是 ATR。"
        },
        {
          "q": "ta.atr(14) 实际上是对 TR 做了什么运算？",
          "choices": [
            {
              "text": "RMA (Wilder's MA)",
              "isCorrect": true
            },
            {
              "text": "SMA",
              "isCorrect": false
            }
          ],
          "explain": "标准 ATR 使用 RMA (Running Moving Average) 平滑。"
        },
        {
          "q": "如果 ATR 上升，意味着？",
          "choices": [
            {
              "text": "K 线变长，波动加剧",
              "isCorrect": true
            },
            {
              "text": "价格上涨",
              "isCorrect": false
            }
          ],
          "explain": "ATR 上升说明近期价格变动幅度增大。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_kdj",
      "title": "指标 5: Stochastic (KD/KDJ)",
      "subtitle": "随机震荡指标",
      "concept": "<h3>核心思路</h3>\n<p>随机指标的直觉很简单：在上升趋势里，收盘价更容易靠近区间高点；在下降趋势里，收盘价更容易靠近区间低点。它把“收盘价在区间中的位置”映射到 0~100，用来观察<b>动量与回撤</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 组成与公式</h4>\n    <p><b>RSV:</b> <code>(Close - Lowest_N) / (Highest_N - Lowest_N) * 100</code></p>\n    <p><b>%K:</b> RSV 的平滑（不同实现的平滑方式略有差别）</p>\n    <p><b>%D:</b> 对 %K 再平滑一次，作为慢线</p>\n    <p><b>J（KDJ 扩展）:</b> <code>J = 3*K - 2*D</code>（更敏感，容易超出 0~100）</p>\n</div>\n<h4>2) 常用信号（别只盯“超买超卖”）</h4>\n<ul>\n    <li><b>交叉:</b> K 上穿 D 偏多，K 下穿 D 偏空。配合区间（如 20/80）会更稳。</li>\n    <li><b>回到区间:</b> 例如从 20 下方重新上穿 20，比“进了超卖就买”更安全。</li>\n    <li><b>背离:</b> 价格创新高但随机指标走弱，提示动量衰竭。</li>\n</ul>\n<h4>3) Pine Script 计算要点</h4>\n<ul>\n    <li><code>ta.stoch(close, high, low, length)</code> 返回的是一条随机线（可视作 %K），想要 %D 需要再做平滑（例如 <code>ta.sma(k, 3)</code>）。</li>\n    <li>如果你要 J 线，需要自行计算 <code>3*k - 2*d</code>。</li>\n</ul>\n<h4>4) 参数与环境选择</h4>\n<ul>\n    <li><b>length 越短:</b> 更敏感，适合短线但假信号多；越长更稳，适合波段。</li>\n    <li><b>趋势市的“钝化”:</b> 强趋势里随机指标可长时间停留在高位/低位，逆势信号风险很大。建议用均线/ADX 先判断环境。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> high/low/close 以及 K/D 平滑参数。</li><li><b>输出:</b> K、D（以及 J 的扩展线），描述价格在区间内的位置与拐点。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>长度与平滑:</b> 控制拐点灵敏度；短周期更适合短线，但更容易噪音。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.stoch(close, high, low, length) 可视作 %K",
        "想要 %D 需对 K 再平滑一次",
        "J=3K-2D 更敏感，可能超出 0~100",
        "交叉+区间过滤更稳，趋势市注意钝化",
        "length 越短越灵敏但假信号更多",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"Stochastic\")\nk = ta.stoch(close, high, low, 14)\nd = ta.sma(k, 3)\nplot(k, color=color.blue)\nplot(d, color=color.orange)",
      "python_code": "# Python (Backtrader)\nclass StochStrategy(bt.Strategy):\n    def __init__(self):\n        self.stoch = bt.indicators.Stochastic(self.data, period=14, period_dfast=3, period_dslow=3)\n        \n    def next(self):\n        # self.stoch.percK\n        # self.stoch.percD\n        pass",
      "quiz": [
        {
          "q": "ta.stoch 计算的是哪条线？",
          "choices": [
            {
              "text": "%K",
              "isCorrect": true
            },
            {
              "text": "%D",
              "isCorrect": false
            }
          ],
          "explain": "ta.stoch 返回的是未平滑的 %K 值，通常需要再做一次 SMA 得到 %D。"
        },
        {
          "q": "KD 指标在超买区死叉通常意味着？",
          "choices": [
            {
              "text": "卖出信号",
              "isCorrect": true
            },
            {
              "text": "买入信号",
              "isCorrect": false
            }
          ],
          "explain": "高位死叉是看跌信号。"
        },
        {
          "q": "KDJ 中的 J 线公式是？",
          "choices": [
            {
              "text": "3K - 2D",
              "isCorrect": true
            },
            {
              "text": "K + D",
              "isCorrect": false
            }
          ],
          "explain": "J 线波动最剧烈，公式为 3*K - 2*D。"
        },
        {
          "q": "Backtrader 的 Stochastic 包含 J 线吗？",
          "choices": [
            {
              "text": "默认不包含",
              "isCorrect": true
            },
            {
              "text": "包含",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 标准 Stochastic 只有 percK 和 percD。"
        },
        {
          "q": "随机指标的核心思想是？",
          "choices": [
            {
              "text": "上涨趋势中收盘价倾向于接近最高价",
              "isCorrect": true
            },
            {
              "text": "成交量决定价格",
              "isCorrect": false
            }
          ],
          "explain": "Stochastic 基于收盘价在近期高低点范围内的相对位置。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_supertrend",
      "title": "指标 6: Supertrend (超级趋势)",
      "subtitle": "基于 ATR 的趋势跟随指标",
      "concept": "<h3>核心思路</h3>\n<p>Supertrend 可以理解为“用 ATR 计算出来的一条动态趋势线 + 趋势状态机”。它的目标不是抓顶抄底，而是：<b>在趋势出现时尽量跟随，在趋势反转时尽快离场</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 组成与骨架公式</h4>\n    <p><b>基准价:</b> 常用 <code>(High + Low) / 2</code></p>\n    <p><b>ATR 通道宽度:</b> <code>factor * ATR(period)</code></p>\n    <p><b>上下轨:</b> 以基准价为中心向上/向下扩展，得到一条“容错带”。</p>\n</div>\n<h4>2) 趋势切换（关键是“用收盘价确认”）</h4>\n<ul>\n    <li>当收盘价突破上方阈值，趋势状态切到看涨；当收盘价跌破下方阈值，趋势状态切到看跌。</li>\n    <li>Supertrend 之所以像移动止损，是因为在看涨状态下它通常在价格下方跟随上移；看跌状态则在价格上方跟随下移。</li>\n</ul>\n<h4>3) 参数怎么调（解决“来回打脸”的问题）</h4>\n<ul>\n    <li><b>factor 越大:</b> 轨道更宽，更不容易被噪音触发反转，但止损更远、回撤更大。</li>\n    <li><b>period 越大:</b> ATR 更平滑，反转更慢但更稳。</li>\n    <li><b>常见组合:</b> 3/10、4/14、2/7（越激进越短）。</li>\n</ul>\n<h4>4) 与其他工具联动（更像一个完整系统）</h4>\n<ul>\n    <li><b>趋势过滤:</b> 可用 ADX 或均线斜率决定是否启用 Supertrend 信号，减少震荡市频繁反转。</li>\n    <li><b>仓位与止损:</b> 既然它基于 ATR，仓位大小也可以用 ATR 做归一化，让风险一致。</li>\n</ul>\n<h4>Pine Script 实现细节</h4>\n<p><code>ta.supertrend(factor, period)</code> 返回 <code>[supertrendValue, direction]</code>。direction 常见取值为 -1/1（其中 <b>-1 通常代表上升趋势</b>）。</p>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> ATR 周期与倍数（mult）。</li><li><b>输出:</b> 跟随价格的趋势线与方向状态（多/空）。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>mult:</b> 越大越不容易被扫掉但回撤可能更大；越小更贴身但更易翻转抖动。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.supertrend(factor, period) 返回值与方向",
        "factor/period 决定灵敏度与回撤大小",
        "震荡市易来回反转，建议先做趋势过滤",
        "基于 ATR，适合与 ATR 风控联动",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"Supertrend\")\n[supertrend, direction] = ta.supertrend(3, 10)\nplot(supertrend, color = direction < 0 ? color.green : color.red)",
      "python_code": "# Python (Backtrader Custom)\n# 需编写自定义 Indicator 类 (见完整代码库)\n# 核心逻辑：\n# basic_upper = (high + low) / 2 + multiplier * atr\n# if close > final_upper: trend = up",
      "quiz": [
        {
          "q": "ta.supertrend 返回值的第二个参数 direction 为负时代表？",
          "choices": [
            {
              "text": "看涨 (Uptrend)",
              "isCorrect": true
            },
            {
              "text": "看跌 (Downtrend)",
              "isCorrect": false
            }
          ],
          "explain": "在 Pine v5 中，direction < 0 (通常为 -1) 代表看涨趋势。"
        },
        {
          "q": "Supertrend 的计算依赖哪个指标？",
          "choices": [
            {
              "text": "ATR",
              "isCorrect": true
            },
            {
              "text": "RSI",
              "isCorrect": false
            }
          ],
          "explain": "Supertrend 使用 ATR 来确定轨道的宽度。"
        },
        {
          "q": "Supertrend 适合什么市场环境？",
          "choices": [
            {
              "text": "趋势明显的市场",
              "isCorrect": true
            },
            {
              "text": "横盘震荡市场",
              "isCorrect": false
            }
          ],
          "explain": "趋势指标在震荡市中会频繁发出错误信号。"
        },
        {
          "q": "Backtrader 自带 Supertrend 指标吗？",
          "choices": [
            {
              "text": "不自带，需自定义",
              "isCorrect": true
            },
            {
              "text": "自带",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 核心库不含 Supertrend，需要继承 bt.Indicator 编写。"
        },
        {
          "q": "Factor 参数通常设置为多少？",
          "choices": [
            {
              "text": "3",
              "isCorrect": true
            },
            {
              "text": "10",
              "isCorrect": false
            }
          ],
          "explain": "默认常用设置是 Factor=3, Period=10。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_vwap",
      "title": "指标 7: VWAP (成交量加权平均价)",
      "subtitle": "机构交易者的基准",
      "concept": "<h3>核心思路</h3>\n<p>VWAP 是“按成交量加权的平均成交价”。它回答的问题不是“价格贵不贵”，而是：<b>今天大家主要在哪个价格区间成交</b>。因此它常被当作日内交易的“公平价”或“基准价”。</p>\n<div class=\"detail-box\">\n    <h4>1) 公式与重置机制</h4>\n    <p><code>VWAP = Sum(Price * Volume) / Sum(Volume)</code></p>\n    <p><b>关键点:</b> 标准 VWAP 是基于交易时段（Session）累加的，通常每天开盘会重置。它不是“永远累加”的均线。</p>\n</div>\n<h4>2) 两类高频用法</h4>\n<ul>\n    <li><b>执行基准（机构视角）:</b> 买入尽量低于 VWAP，卖出尽量高于 VWAP，用它评估成交质量（执行好不好）。</li>\n    <li><b>交易参考（日内视角）:</b> 价格在 VWAP 上方偏强，在下方偏弱；回踩 VWAP 不破可能是顺势加仓/二次入场点。</li>\n</ul>\n<h4>3) 进阶：VWAP 不是一条线就完了</h4>\n<ul>\n    <li><b>VWAP Bands:</b> 很多交易者会用标准差或 ATR 在 VWAP 上下做带子，形成“VWAP 通道”，用于均值回归或突破判断。</li>\n    <li><b>Anchored/Midas VWAP:</b> 以某个关键事件/拐点为起点开始累加，常用于分析“从某次放量突破以来的平均成本”。</li>\n</ul>\n<h4>4) 使用限制与注意事项</h4>\n<ul>\n    <li><b>需要成交量:</b> 没有 volume 的品种无法计算（或没有意义）。</li>\n    <li><b>更适合日内:</b> 在日线/周线图上 Session 的意义会弱化，VWAP 往往不如日内直观。</li>\n    <li><b>24/7 品种:</b> 加密货币等全天交易品种的“每日重置”依赖交易所/图表的会话定义，解读时要一致。</li>\n</ul>\n<h4>Pine Script 实现细节</h4>\n<p><code>ta.vwap(source)</code> 会按会话处理重置。想做 Rolling VWAP/Anchored VWAP 需要手写累加逻辑。</p>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> 典型价与成交量（由图表数据提供），常配合会话/日内重置。</li><li><b>输出:</b> 成交量加权均价，常作为机构成本线的近似。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>会话重置:</b> 日内 VWAP 通常按交易日重置；跨日品种要明确边界。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "VWAP=成交量加权平均价，常被当作“公平价”",
        "ta.vwap(source) 会按会话处理重置",
        "日内更有效，缺少成交量则不可用/无意义",
        "可扩展为 VWAP Bands 或 Anchored VWAP",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"VWAP\")\nplot(ta.vwap(close))",
      "python_code": "# Python (Backtrader Custom)\nclass VWAP(bt.Indicator):\n    def next(self):\n        if self.data.datetime.date(0) != self.data.datetime.date(-1):\n            self.cum_vol = 0\n            self.cum_pv = 0\n        # 累加计算...",
      "quiz": [
        {
          "q": "VWAP 通常在什么时候重置？",
          "choices": [
            {
              "text": "每天开盘",
              "isCorrect": true
            },
            {
              "text": "永不重置",
              "isCorrect": false
            }
          ],
          "explain": "标准 VWAP 是 Session VWAP，每日重置。"
        },
        {
          "q": "机构算法交易常用 VWAP 做什么？",
          "choices": [
            {
              "text": "作为执行价格的基准 (Benchmark)",
              "isCorrect": true
            },
            {
              "text": "预测明天价格",
              "isCorrect": false
            }
          ],
          "explain": "机构致力于以优于 VWAP 的价格成交。"
        },
        {
          "q": "ta.vwap(source) 在 Pine 中可以用于日线图吗？",
          "choices": [
            {
              "text": "不可以 (显示为一条线或无意义)",
              "isCorrect": true
            },
            {
              "text": "可以",
              "isCorrect": false
            }
          ],
          "explain": "标准 VWAP 是日内指标，在日线图上每根 Bar 就是一整天，无法体现日内 VWAP 变化，或者变成 Annual VWAP。"
        },
        {
          "q": "计算 VWAP 必须要有哪个数据？",
          "choices": [
            {
              "text": "Volume (成交量)",
              "isCorrect": true
            },
            {
              "text": "Open Interest",
              "isCorrect": false
            }
          ],
          "explain": "没有成交量无法计算加权平均。"
        },
        {
          "q": "Midas VWAP 是什么？",
          "choices": [
            {
              "text": "从特定时间点开始计算的 VWAP",
              "isCorrect": true
            },
            {
              "text": "基于黄金分割的 VWAP",
              "isCorrect": false
            }
          ],
          "explain": "Midas VWAP 允许用户指定起始点（如通过鼠标点击或特定事件）。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_ichimoku",
      "title": "指标 8: Ichimoku (一目均衡表)",
      "subtitle": "云图系统",
      "concept": "<h3>核心思路</h3>\n<p>一目均衡表不是“一个指标”，而是一套系统：它同时给你<b>趋势方向、支撑阻力、动量变化、以及时间位移</b>。读一目最重要的是：先看“云”判断环境，再看线与线的关系决定进出。</p>\n<div class=\"detail-box\">\n    <h4>1) 五条线 + 位移（最容易混淆的点）</h4>\n    <p><b>转折线 Tenkan:</b> <code>(Highest(9) + Lowest(9)) / 2</code></p>\n    <p><b>基准线 Kijun:</b> <code>(Highest(26) + Lowest(26)) / 2</code></p>\n    <p><b>先行带 A:</b> <code>(Tenkan + Kijun) / 2</code>，<b>向前</b>位移 26</p>\n    <p><b>先行带 B:</b> <code>(Highest(52) + Lowest(52)) / 2</code>，<b>向前</b>位移 26</p>\n    <p><b>迟行带 Chikou:</b> <code>Close</code>，<b>向后</b>位移 26</p>\n</div>\n<h4>2) 读图顺序（建议照这个来）</h4>\n<ul>\n    <li><b>先看价格与云:</b> 云上=偏多，云下=偏空，云内=震荡/不确定。</li>\n    <li><b>再看云的厚度:</b> 云越厚，支撑/阻力越强；云越薄，越容易被突破。</li>\n    <li><b>再看 Tenkan/Kijun:</b> 类似快慢线，交叉给出动量变化；但交叉发生在云上/云下，可靠性差异很大。</li>\n    <li><b>最后看 Chikou:</b> 用“当前价格（后移）是否穿越过去的价格/云”做确认，减少假信号。</li>\n</ul>\n<h4>3) 常见信号（从弱到强）</h4>\n<ul>\n    <li><b>Tenkan/Kijun 交叉:</b> 基础信号；发生在云上更强，在云内最弱。</li>\n    <li><b>价格突破云:</b> 常被视为趋势切换信号；配合云未来形态（Kumo Twist）更有信息量。</li>\n    <li><b>云未来扭转（Kumo Twist）:</b> Span A/B 先行扭转，提示未来支撑/阻力结构变化。</li>\n</ul>\n<h4>4) 实盘注意</h4>\n<ul>\n    <li><b>位移不是未来函数:</b> 先行带是把已经计算出的值画到未来位置，用于视觉化未来的支撑/阻力投影，不是“偷看未来”。</li>\n    <li><b>参数 9/26/52 是经典值:</b> 不要轻易微调到过拟合，先把读图逻辑用熟。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> Tenkan/Kijun/Senkou 相关周期。</li><li><b>输出:</b> 转换线、基准线、先行 A/B（云）、迟行线，提供趋势与结构框架。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>位移:</b> 先行线向右偏移、迟行线向左偏移；读图与回测必须理解时间对齐。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "一目=趋势+结构+位移的综合系统",
        "读图先看云：云上偏多，云下偏空，云内震荡",
        "Tenkan/Kijun 交叉要结合云位置判断强弱",
        "先行位移是绘图位移，不等于未来函数",
        "参数 9/26/52 先用经典值，避免过拟合",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"Ichimoku\")\ntenkan = math.avg(ta.lowest(9), ta.highest(9))\nkijun = math.avg(ta.lowest(26), ta.highest(26))\nspanA = math.avg(tenkan, kijun)\nspanB = math.avg(ta.lowest(52), ta.highest(52))\nplot(tenkan, color=color.blue)\nplot(kijun, color=color.red)",
      "python_code": "# Python (Backtrader)\nichi = bt.indicators.Ichimoku(self.data)\n# ichi.l.tenkan_sen\n# ichi.l.kijun_sen\n# ichi.l.senkou_span_a",
      "quiz": [
        {
          "q": "一目均衡表的基准线 (Kijun-sen) 计算公式是？",
          "choices": [
            {
              "text": "(过去26日最高 + 最低) / 2",
              "isCorrect": true
            },
            {
              "text": "26日 SMA",
              "isCorrect": false
            }
          ],
          "explain": "一目云使用 (High+Low)/2 的中点算法，而非收盘价均值。"
        },
        {
          "q": "“云”是由哪两条线组成的？",
          "choices": [
            {
              "text": "先行带 A 和 先行带 B",
              "isCorrect": true
            },
            {
              "text": "转折线 和 基准线",
              "isCorrect": false
            }
          ],
          "explain": "Senkou Span A 和 Senkou Span B 围成了云。"
        },
        {
          "q": "迟行带 (Chikou Span) 是什么？",
          "choices": [
            {
              "text": "当前收盘价向后平移 26 周期",
              "isCorrect": true
            },
            {
              "text": "当前收盘价向前平移",
              "isCorrect": false
            }
          ],
          "explain": "迟行带是当前价格在时间轴上后移，用于和历史价格对比。"
        },
        {
          "q": "价格在云层上方意味着？",
          "choices": [
            {
              "text": "上升趋势",
              "isCorrect": true
            },
            {
              "text": "下降趋势",
              "isCorrect": false
            }
          ],
          "explain": "云层起到支撑作用。"
        },
        {
          "q": "Backtrader 内置 Ichimoku 指标吗？",
          "choices": [
            {
              "text": "内置",
              "isCorrect": true
            },
            {
              "text": "不内置",
              "isCorrect": false
            }
          ],
          "explain": "bt.indicators.Ichimoku 是内置指标。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_cci",
      "title": "指标 9: CCI (顺势指标)",
      "subtitle": "商品通道指标",
      "concept": "<h3>核心思路</h3>\n<p>CCI 的核心是：价格（典型价）距离自身均值有多“离谱”。它用平均绝对偏差（MAD）做归一化，所以 CCI 不是简单的“价格减均线”，而是把偏离程度标准化，用于识别<b>异常强势/异常弱势</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 公式与含义</h4>\n    <p><code>CCI = (TP - SMA(TP)) / (0.015 * MeanDeviation)</code></p>\n    <ul>\n        <li><b>TP:</b> <code>(High + Low + Close) / 3</code></li>\n        <li><b>MeanDeviation:</b> <code>Mean(|TP - SMA(TP)|)</code></li>\n        <li><b>0.015:</b> 用来让大部分数值落在 -100~+100 附近，便于解读阈值。</li>\n    </ul>\n</div>\n<h4>2) 两种常用打法（先定环境再选）</h4>\n<ul>\n    <li><b>趋势/动量突破:</b> CCI 上穿 +100 视为动量增强，配合趋势过滤做顺势。</li>\n    <li><b>均值回归:</b> CCI 远离区间后回到 -100~+100 内，视为“异常状态结束”，寻找回归机会。</li>\n</ul>\n<h4>3) 参数与风险点</h4>\n<ul>\n    <li><b>length 越短:</b> 更敏感但抖动大；越长更稳但更滞后。</li>\n    <li><b>极端值不等于立刻反转:</b> 强趋势中 CCI 可能长时间维持高位/低位，逆势很危险。</li>\n</ul>\n<h4>4) 组合用法（提升相关性）</h4>\n<ul>\n    <li>用 ADX/均线判断趋势环境，再选择“突破”或“回归”。</li>\n    <li>用 ATR 统一止损距离，避免不同波动品种同样阈值风险不一致。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> source（常用 hlc3）与 length。</li><li><b>输出:</b> 围绕 0 震荡的偏离度指标，常用 100 判断强弱。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>阈值:</b> 100/200 仅作参考，建议按历史分布校准。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ta.cci(source, length) 用 MAD 归一化偏离",
        "阈值 -100/+100 便于识别异常强弱",
        "可做动量突破，也可做均值回归",
        "强趋势里极端值会持续，逆势要谨慎",
        "常与 ADX/ATR 组合做过滤与风控",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"CCI\")\nplot(ta.cci(close, 20))",
      "python_code": "# Python (Backtrader)\ncci = bt.indicators.CCI(self.data, period=20)",
      "quiz": [
        {
          "q": "CCI 设计之初是为了分析什么市场？",
          "choices": [
            {
              "text": "商品期货 (Commodities)",
              "isCorrect": true
            },
            {
              "text": "股票",
              "isCorrect": false
            }
          ],
          "explain": "名字 Commodity Channel Index 说明了起源。"
        },
        {
          "q": "CCI 的常数系数通常是？",
          "choices": [
            {
              "text": "0.015",
              "isCorrect": true
            },
            {
              "text": "0.05",
              "isCorrect": false
            }
          ],
          "explain": "Lambert 选用了 0.015 使得约 70-80% 的数据落在 -100 到 +100 之间。"
        },
        {
          "q": "CCI 上穿 +100 可以视为？",
          "choices": [
            {
              "text": "强势突破或超买",
              "isCorrect": true
            },
            {
              "text": "超卖",
              "isCorrect": false
            }
          ],
          "explain": "视策略而定，可以看作动量突破做多，也可以看作超买做空。"
        },
        {
          "q": "CCI 计算中使用的是什么价格？",
          "choices": [
            {
              "text": "典型价格 (High+Low+Close)/3",
              "isCorrect": true
            },
            {
              "text": "收盘价",
              "isCorrect": false
            }
          ],
          "explain": "标准 CCI 使用 Typical Price。"
        },
        {
          "q": "ta.cci(close, 20) 的第二个参数是？",
          "choices": [
            {
              "text": "周期长度",
              "isCorrect": true
            },
            {
              "text": "平滑因子",
              "isCorrect": false
            }
          ],
          "explain": "Length 周期。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "ind_adx",
      "title": "指标 10: ADX (平均趋向指标)",
      "subtitle": "判断趋势的强度",
      "concept": "<h3>核心思路</h3>\n<p>ADX 只回答一个问题：<b>现在是不是“有趋势”的市场</b>。它不告诉你涨还是跌，方向要看 DI+ 与 DI- 或者直接看价格。</p>\n<div class=\"detail-box\">\n    <h4>1) 三个核心量：DI+、DI-、ADX</h4>\n    <p><b>DI+ / DI-:</b> 反映上行/下行动量的相对强弱</p>\n    <p><b>ADX:</b> 对“DI 差异程度”的平滑，数值越大表示趋势越强（无论涨跌）</p>\n    <p>Pine 可用 <code>ta.dmi(length, lensig)</code> 一次拿到 <code>[diPlus, diMinus, adx]</code>。</p>\n</div>\n<h4>2) 怎么用 ADX（最常见的正确用法）</h4>\n<ul>\n    <li><b>做过滤器，不做直接进出场:</b> 例如“ADX>25 才允许用突破/趋势策略”，“ADX<20 才允许用均值回归策略”。</li>\n    <li><b>方向判断:</b> DI+>DI- 偏多，DI+<DI- 偏空；但方向信号也需要结合价格结构确认。</li>\n</ul>\n<h4>3) 阈值是经验，不是铁律</h4>\n<ul>\n    <li><b>常用区间:</b> 15~20 低趋势；25 以上趋势明显；40 以上可能进入“强趋势/加速段”。</li>\n    <li><b>不同品种会偏移:</b> 高波动品种 ADX 可能长期偏高，最好用历史分位数做校准。</li>\n</ul>\n<h4>4) 常见坑</h4>\n<ul>\n    <li><b>ADX 高不等于看涨:</b> 暴跌时 ADX 也会很高。</li>\n    <li><b>ADX 抬头不等于趋势立刻盈利:</b> 趋势强度上升往往滞后于价格突破，仍需风控。</li>\n</ul>\n<h3>输入 / 输出（把指标当成函数来用）</h3>\n<ul>\n  <li><b>输入:</b> length（常用 14）。</li><li><b>输出:</b> 趋势强度（不含方向），常与 +DI/-DI 结合。</li>\n</ul>\n<h3>关键参数与边界条件</h3>\n<ul>\n  <li><b>阈值:</b> 20/25/30 是常见参考，需结合周期与品种重新评估。</li>\n  <li><b>历史不足:</b> 前若干根会得到 <code>na</code>，信号逻辑要显式处理（例如 <code>not na(x)</code>）。</li>\n  <li><b>确认时机:</b> 交叉/突破类信号建议收盘确认，避免盘中来回穿越。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>先环境后信号:</b> 震荡/趋势环境不同，同一个指标的读法完全不同。</li>\n  <li><b>避免过拟合:</b> 参数不要只在一段历史上调到极致，至少做分段与滚动验证。</li>\n  <li><b>风险优先:</b> 指标负责方向/状态，止损止盈应独立设计（ATR/结构位/时间止损）。</li>\n</ul>\n",
      "summary": [
        "ADX 衡量趋势强度，不判断方向",
        "方向通常用 DI+ 与 DI- 或价格结构确认",
        "最常见用法：作为趋势/震荡环境过滤器",
        "25/20 是经验阈值，不同品种需校准",
        "ADX 高可能是暴涨也可能是暴跌",
        "把指标当成函数：先想清楚输入与输出，再谈信号",
        "信号尽量收盘确认，并显式处理历史不足的 na"
      ],
      "pine_code": "//@version=5\nindicator(\"ADX\")\n[diplus, diminus, adx] = ta.dmi(14, 14)\nplot(adx, color=color.red)",
      "python_code": "# Python (Backtrader)\nadx = bt.indicators.ADX(self.data, period=14)\n# adx.adx 是强度\n# 也有 DMI 指标包含 DI+ DI-",
      "quiz": [
        {
          "q": "ADX 值很高代表什么？",
          "choices": [
            {
              "text": "趋势很强（无论涨跌）",
              "isCorrect": true
            },
            {
              "text": "价格很高",
              "isCorrect": false
            },
            {
              "text": "一定是上涨趋势",
              "isCorrect": false
            }
          ],
          "explain": "ADX 仅衡量强度，不分方向。暴跌时 ADX 也会飙升。"
        },
        {
          "q": "判断趋势方向需要配合什么？",
          "choices": [
            {
              "text": "+DI 和 -DI",
              "isCorrect": true
            },
            {
              "text": "RSI",
              "isCorrect": false
            }
          ],
          "explain": "当 +DI > -DI 为涨势。"
        },
        {
          "q": "ADX 低于 20 通常建议？",
          "choices": [
            {
              "text": "不使用趋势策略，改用震荡策略",
              "isCorrect": true
            },
            {
              "text": "加仓",
              "isCorrect": false
            }
          ],
          "explain": "低 ADX 意味着市场无序震荡。"
        },
        {
          "q": "ta.dmi() 函数返回什么？",
          "choices": [
            {
              "text": "[di+, di-, adx]",
              "isCorrect": true
            },
            {
              "text": "adx",
              "isCorrect": false
            }
          ],
          "explain": "Pine v5 的 dmi 函数一次性返回三个分量。"
        },
        {
          "q": "Backtrader 的 ADX 指标默认周期是？",
          "choices": [
            {
              "text": "14",
              "isCorrect": true
            },
            {
              "text": "10",
              "isCorrect": false
            }
          ],
          "explain": "14 是标准默认值。"
        }
      ],
      "category": "内置指标 (Built-in Indicators)",
      "isLocked": true
    },
    {
      "id": "l8_strategy_basics",
      "title": "策略 1: 策略回测基础",
      "subtitle": "strategy.entry, strategy.close",
      "concept": "<h3>策略脚本的本质</h3>\n<p>Pine 的策略脚本本质上是：在每根 K 线上<b>顺序执行一次</b>你的逻辑，然后把“下单指令”交给内置回测引擎去撮合与统计。</p>\n<div class=\"detail-box\">\n    <h4>1) strategy() 里决定回测世界观</h4>\n    <ul>\n        <li><b>资金与手续费:</b> initial_capital / commission_type / commission_value</li>\n        <li><b>滑点:</b> slippage（越接近真实越好，但回测会更保守）</li>\n        <li><b>加仓限制:</b> pyramiding（网格/DCA 必须调大）</li>\n        <li><b>执行模型:</b> 默认信号出现后在下一根 Bar 执行（这点决定你能否“用收盘价确认”）</li>\n    </ul>\n</div>\n<h4>2) 三个最常用的下单函数（理解它们的职责）</h4>\n<ul>\n    <li><code>strategy.entry(id, direction, ...)</code>: 负责<b>开仓/加仓/反手</b>（同一个 id 会被引擎当作同一条“入场逻辑”管理）。</li>\n    <li><code>strategy.close(id)</code>: 负责<b>把某个 entry id 的仓位平掉</b>（不带止盈止损参数）。</li>\n    <li><code>strategy.exit(id, from_entry, ...)</code>: 负责<b>出场规则</b>，能同时挂止损/止盈/移动止损（典型 OCO 结构）。</li>\n</ul>\n<h4>3) id 的意义（新手最容易忽略）</h4>\n<ul>\n    <li><b>entry id:</b> 决定你在管理哪一条仓位；同一 id 的多次 entry 在允许 pyramiding 时会叠加。</li>\n    <li><b>from_entry:</b> exit 必须绑定到某个入场 id，否则回测引擎不知道你要管理哪笔仓位。</li>\n</ul>\n<h4>4) 实盘化思维：先把“信号”与“风控”绑在一起</h4>\n<ul>\n    <li>不要只写 entry/close，尽量在入场后立刻用 exit 设置止损/止盈/移动止损。</li>\n    <li>回测必须纳入手续费与滑点，否则策略往往虚高。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "strategy() 决定资金、手续费、滑点与 pyramiding",
        "entry 管入场/加仓/反手，close 管直接平仓",
        "exit 管止盈止损与移动止损（典型 OCO）",
        "id/from_entry 决定仓位与出场绑定关系",
        "回测务必纳入手续费与滑点",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Simple Strategy\", overlay=true)\n\nma14 = ta.sma(close, 14)\nma28 = ta.sma(close, 28)\n\nif ta.crossover(ma14, ma28)\n    strategy.entry(\"Long\", strategy.long)\n\nif ta.crossunder(ma14, ma28)\n    strategy.close(\"Long\")",
      "python_code": "# Python (Backtrader)\nclass MyStrat(bt.Strategy):\n    def next(self):\n        # 检查是否持仓\n        if not self.position:\n            # 策略逻辑：金叉买入\n            if self.ma14[0] > self.ma28[0] and self.ma14[-1] <= self.ma28[-1]:\n                self.buy()\n        else:\n            # 策略逻辑：死叉卖出\n            if self.ma14[0] < self.ma28[0] and self.ma14[-1] >= self.ma28[-1]:\n                self.close()",
      "quiz": [
        {
          "q": "strategy.entry(\"Long\", strategy.long) 的作用是什么？",
          "choices": [
            {
              "text": "只买入 1 手",
              "isCorrect": false
            },
            {
              "text": "开多单，如果持有空单会先平空再开多",
              "isCorrect": true
            },
            {
              "text": "平掉多单",
              "isCorrect": false
            }
          ],
          "explain": "strategy.entry 会根据方向调整仓位。如果当前持有反向仓位，它会先平反向仓位，再开新方向的仓位（实现反手）。"
        },
        {
          "q": "strategy.close(\"Long\") 会做什么？",
          "choices": [
            {
              "text": "平掉 ID 为 'Long' 的仓位",
              "isCorrect": true
            },
            {
              "text": "开空单",
              "isCorrect": false
            },
            {
              "text": "关闭脚本",
              "isCorrect": false
            }
          ],
          "explain": "close 用于平仓，使仓位归零。"
        },
        {
          "q": "Backtrader 中检查当前是否持仓的属性是？",
          "choices": [
            {
              "text": "self.position",
              "isCorrect": true
            },
            {
              "text": "self.holding",
              "isCorrect": false
            },
            {
              "text": "self.has_order",
              "isCorrect": false
            }
          ],
          "explain": "self.position 返回当前持仓对象，如果不为 None/0 则表示有持仓。"
        },
        {
          "q": "Pine 策略回测参数在哪里设置？",
          "choices": [
            {
              "text": "strategy() 函数的参数中",
              "isCorrect": true
            },
            {
              "text": "indicator() 函数中",
              "isCorrect": false
            },
            {
              "text": "无法设置",
              "isCorrect": false
            }
          ],
          "explain": "可以在 strategy() 中设置 initial_capital, commission_value 等参数。"
        },
        {
          "q": "strategy.long 代表什么方向？",
          "choices": [
            {
              "text": "做多 (Buy)",
              "isCorrect": true
            },
            {
              "text": "做空 (Sell)",
              "isCorrect": false
            }
          ],
          "explain": "strategy.long 代表多头方向，strategy.short 代表空头方向。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "l9_risk_management",
      "title": "策略 2: 风险管理 (SL/TP)",
      "subtitle": "strategy.exit 实现止盈止损",
      "concept": "<h3>风险管理的关键</h3>\n<p>好的策略不是“信号准”，而是：<b>亏的时候亏得少，赢的时候让它多赢一点</b>。在 Pine 里，风险管理几乎都围绕 <code>strategy.exit</code> 来做。</p>\n<div class=\"detail-box\">\n    <h4>1) strategy.exit 的三种表达方式</h4>\n    <ul>\n        <li><b>按价格:</b> <code>stop=price</code> / <code>limit=price</code></li>\n        <li><b>按点数:</b> <code>loss=points</code> / <code>profit=points</code>（更像“距离”）</li>\n        <li><b>按追踪:</b> <code>trail_points</code> / <code>trail_offset</code>（移动止损）</li>\n    </ul>\n    <p><b>注意:</b> <code>from_entry</code> 必须绑定 entry id，否则无法管理对应仓位。</p>\n</div>\n<h4>2) OCO（一个成交，另一个取消）</h4>\n<p>当你同时挂止盈与止损，本质上就是 OCO。触发其中一个后，引擎会自动取消另一个，避免重复出场。</p>\n<h4>3) 常见做法（更贴近实盘）</h4>\n<ul>\n    <li><b>固定风险预算:</b> 每笔交易只冒 0.5%~2% 风险，仓位大小由止损距离决定。</li>\n    <li><b>动态止损:</b> 用 ATR 设止损（如 <code>stop = entryPrice - k*ATR</code>），不同波动环境风险一致。</li>\n    <li><b>时间止损:</b> 进场后若 N 根 K 线还没走出预期就退出，避免资金占用。</li>\n</ul>\n<h4>4) 回测陷阱（必须知道）</h4>\n<ul>\n    <li><b>跳空与滑点:</b> 止损未必按你设的价格成交，务必设置 slippage 与手续费。</li>\n    <li><b>盘中触发:</b> 你的策略若只在收盘计算，止损/止盈触发的细节会受 bar 内路径影响，解释结果时要谨慎。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "strategy.exit 必须绑定 from_entry",
        "stop/limit 用价格；loss/profit 用点数距离",
        "止盈止损组合即 OCO：成交其一取消其二",
        "常用 ATR 动态止损，统一不同波动风险",
        "回测要纳入滑点与跳空风险",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Risk Mgmt\", overlay=true)\n\n// 计算均线\nfast = ta.sma(close, 10)\nslow = ta.sma(close, 20)\n\n// 入场条件：金叉\nif ta.crossover(fast, slow)\n    strategy.entry(\"MyLong\", strategy.long)\n    \n    // strategy.exit 用于管理仓位退出\n    // profit: 止盈点数 (ticks)\n    // loss: 止损点数 (ticks)\n    strategy.exit(\"Exit\", \"MyLong\", profit=100, loss=50)",
      "python_code": "# Python (Backtrader)\nclass RiskStrategy(bt.Strategy):\n    def next(self):\n        # 假设已满足入场条件\n        if self.crossover > 0:\n            # 市价单买入\n            self.buy()\n            \n            # Backtrader 实现止盈止损通常需要手动管理订单\n            # 或者使用 OCO (One Cancels Other) 订单组\n            \n            price = self.data.close[0]\n            # 假设 1 点 = 1 美元\n            stop_price = price - 50 \n            limit_price = price + 100\n            \n            # 提交止损单\n            self.sell(exectype=bt.Order.Stop, price=stop_price)\n            # 提交止盈单\n            self.sell(exectype=bt.Order.Limit, price=limit_price)",
      "quiz": [
        {
          "q": "strategy.exit() 中 profit=100 的单位是什么？",
          "choices": [
            {
              "text": "价格",
              "isCorrect": false
            },
            {
              "text": "百分比",
              "isCorrect": false
            },
            {
              "text": "点数 (Ticks/Points)",
              "isCorrect": true
            }
          ],
          "explain": "profit 和 loss 参数通常是指最小价格变动单位（Ticks）或点数，具体取决于 symbol 设置。"
        },
        {
          "q": "如果想按具体价格止损，应该用哪个参数？",
          "choices": [
            {
              "text": "loss",
              "isCorrect": false
            },
            {
              "text": "stop",
              "isCorrect": true
            },
            {
              "text": "limit",
              "isCorrect": false
            }
          ],
          "explain": "stop 参数指定止损触发的价格水平。"
        },
        {
          "q": "OCO (One Cancels Other) 订单是什么意思？",
          "choices": [
            {
              "text": "止盈和止损单，一个成交后另一个自动取消",
              "isCorrect": true
            },
            {
              "text": "必须同时成交",
              "isCorrect": false
            },
            {
              "text": "只能手动取消",
              "isCorrect": false
            }
          ],
          "explain": "strategy.exit 创建的止盈止损对就是典型的 OCO 订单。"
        },
        {
          "q": "Backtrader 中如何实现 OCO？",
          "choices": [
            {
              "text": "自动实现",
              "isCorrect": false
            },
            {
              "text": "使用 transmit=False 和 parent 参数",
              "isCorrect": true
            }
          ],
          "explain": "在 Backtrader 中创建 Bracket Order 需要将主单的 transmit 设为 False，并将止盈止损单关联到主单。"
        },
        {
          "q": "Trailing Stop (移动止损) 可以在 strategy.exit 中设置吗？",
          "choices": [
            {
              "text": "可以 (trail_price, trail_offset)",
              "isCorrect": true
            },
            {
              "text": "不可以",
              "isCorrect": false
            }
          ],
          "explain": "strategy.exit 支持 trail_points/price/offset 参数来实现移动止损。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_dual_ma",
      "title": "策略 3: 双均线交叉 (Dual MA)",
      "subtitle": "最简单的趋势策略",
      "concept": "<h3>策略原理</h3>\n<p>双均线交叉用“快线追随价格、慢线代表趋势”的思想，把趋势判断简化成一个可执行的规则：<b>趋势出现就跟随，趋势消失就退出</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 核心规则</h4>\n    <p><b>入场:</b> Fast 上穿 Slow（趋势开始）</p>\n    <p><b>出场:</b> Fast 下穿 Slow（趋势结束）</p>\n</div>\n<h4>2) 为什么它能赚钱（但也会亏）</h4>\n<ul>\n    <li><b>赚钱来源:</b> 捕捉少数几段大趋势，单笔盈利覆盖多次小亏。</li>\n    <li><b>亏钱来源:</b> 震荡市“来回穿越”，产生连续 whipsaw。</li>\n</ul>\n<h4>3) 参数与类型（进阶但非常关键）</h4>\n<ul>\n    <li><b>均线类型:</b> EMA 比 SMA 更敏感，信号更早但更噪；SMA 更稳但更滞后。</li>\n    <li><b>周期差:</b> Fast/Slow 间距越大，过滤越强但更慢；间距越小越灵敏但更容易打脸。</li>\n</ul>\n<h4>4) 常见强化（让策略更“可用”）</h4>\n<ul>\n    <li><b>趋势过滤:</b> ADX>25 或慢线斜率为正时才做多，减少震荡交易。</li>\n    <li><b>风控:</b> 用 ATR 止损/移动止损，避免一次反向波动把利润吐完。</li>\n    <li><b>多周期:</b> 大周期判断趋势，小周期执行进场，提升胜率但要避免重绘。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "用 crossover/crossunder 捕捉趋势启动与结束",
        "趋势段盈利覆盖震荡期多次小亏",
        "EMA 更敏感，SMA 更稳；周期差决定过滤强度",
        "ADX/均线斜率可做震荡过滤",
        "ATR 止损/移动止损提升可用性",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Dual MA\", overlay=true)\nfast = ta.sma(close, 10)\nslow = ta.sma(close, 20)\n\nif ta.crossover(fast, slow)\n    strategy.entry(\"Long\", strategy.long)\nif ta.crossunder(fast, slow)\n    strategy.close(\"Long\")",
      "python_code": "# Python (Backtrader)\nif self.fast[0] > self.slow[0] and self.fast[-1] <= self.slow[-1]:\n    self.buy()\nelif self.fast[0] < self.slow[0] and self.fast[-1] >= self.slow[-1]:\n    self.close()",
      "quiz": [
        {
          "q": "双均线策略的主要缺点是？",
          "choices": [
            {
              "text": "震荡市频繁止损 (Whipsaw)",
              "isCorrect": true
            },
            {
              "text": "无法捕捉大趋势",
              "isCorrect": false
            }
          ],
          "explain": "在没有趋势的震荡行情中，均线会频繁交叉导致不断亏损。"
        },
        {
          "q": "Golden Cross (金叉) 是指？",
          "choices": [
            {
              "text": "短周期均线上穿长周期均线",
              "isCorrect": true
            },
            {
              "text": "长周期均线上穿短周期均线",
              "isCorrect": false
            }
          ],
          "explain": "快线上穿慢线。"
        },
        {
          "q": "如何优化均线策略？",
          "choices": [
            {
              "text": "加入趋势过滤器 (如 ADX)",
              "isCorrect": true
            },
            {
              "text": "缩短周期",
              "isCorrect": false
            }
          ],
          "explain": "引入 ADX 或其他过滤器避免在震荡市交易是常见优化手段。"
        },
        {
          "q": "Backtrader 中 CrossOver 指标可以简化逻辑吗？",
          "choices": [
            {
              "text": "可以 (bt.ind.CrossOver)",
              "isCorrect": true
            },
            {
              "text": "不可以",
              "isCorrect": false
            }
          ],
          "explain": "bt.indicators.CrossOver(fast, slow) 会返回 1 (上穿) 或 -1 (下穿)。"
        },
        {
          "q": "均线属于什么类型的指标？",
          "choices": [
            {
              "text": "滞后指标 (Lagging)",
              "isCorrect": true
            },
            {
              "text": "领先指标 (Leading)",
              "isCorrect": false
            }
          ],
          "explain": "均线基于历史价格计算，信号总是滞后于价格变化。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_rsi_reversal",
      "title": "策略 4: RSI 均值回归",
      "subtitle": "超卖买入，超买卖出",
      "concept": "<h3>策略原理</h3>\n<p>RSI 均值回归是典型的“买在恐慌、卖在亢奋”。但真正可用的版本不是“RSI 进超卖就买”，而是：<b>等待极端状态结束的确认</b>，并且在不适合的环境里坚决不做。</p>\n<div class=\"detail-box\">\n    <h4>1) 更稳的入场方式</h4>\n    <p><b>做多:</b> RSI 跌破 30 后，重新上穿 30 才进场（确认“卖压衰竭”）。</p>\n    <p><b>出场:</b> 常用 RSI 回到 50 附近、或 RSI 上穿 70 后回落、或价格回到均线/布林中轨。</p>\n</div>\n<h4>2) 关键风险：钝化与趋势惩罚</h4>\n<ul>\n    <li><b>强趋势里 RSI 会钝化:</b> 超卖可能持续很久，逆势抄底极易多次加仓后深套。</li>\n    <li><b>解决思路:</b> 只有在“震荡环境”才做回归（例如 ADX<20、或价格在区间内、或远离长期均线不追单）。</li>\n</ul>\n<h4>3) 强化版规则（让策略更闭环）</h4>\n<ul>\n    <li><b>趋势过滤:</b> 只在价格高于长期均线时做多回归；只在价格低于长期均线时做空回归。</li>\n    <li><b>波动止损:</b> 用 ATR 设置止损距离，避免固定点数不适配不同品种。</li>\n    <li><b>时间止损:</b> 进场后若 N 根 K 线仍未回归则退出，减少“慢刀子割肉”。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "更稳：先极端，再回到阈值内确认入场",
        "震荡更适合回归，强趋势里容易钝化接飞刀",
        "常用 ADX/均线做环境过滤",
        "ATR 止损与时间止损让风险可控",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"RSI Reversal\")\nr = ta.rsi(close, 14)\nif ta.crossover(r, 30)\n    strategy.entry(\"Long\", strategy.long)\nif ta.crossunder(r, 70)\n    strategy.close(\"Long\")",
      "python_code": "# Python (Backtrader)\nif not self.position:\n    if self.rsi[0] < 30:\n        self.buy()\nelse:\n    if self.rsi[0] > 70:\n        self.sell()",
      "quiz": [
        {
          "q": "RSI 均值回归策略最怕什么行情？",
          "choices": [
            {
              "text": "单边暴涨暴跌",
              "isCorrect": true
            },
            {
              "text": "横盘震荡",
              "isCorrect": false
            }
          ],
          "explain": "在强趋势中，RSI 会长时间停留在超买/超卖区，导致过早逆势开仓被套。"
        },
        {
          "q": "如何改进 RSI 回归策略？",
          "choices": [
            {
              "text": "等待 RSI 重新回到正常区域再交易",
              "isCorrect": true
            },
            {
              "text": "一进入超卖区马上买",
              "isCorrect": false
            }
          ],
          "explain": "更好的做法是等 RSI 从下方穿回 30 以上确认反转。"
        },
        {
          "q": "Conners RSI 是什么？",
          "choices": [
            {
              "text": "一种适合短线回归的改进版 RSI",
              "isCorrect": true
            },
            {
              "text": "长周期 RSI",
              "isCorrect": false
            }
          ],
          "explain": "Conners RSI 结合了 RSI、连涨/连跌天数和 ROC，更适合短线反转。"
        },
        {
          "q": "Strategy.entry 的默认执行价格是？",
          "choices": [
            {
              "text": "开盘时的市价 (Market)",
              "isCorrect": true
            },
            {
              "text": "限价",
              "isCorrect": false
            }
          ],
          "explain": "默认是 Market 单，在信号产生的下一根 Bar 开盘执行。"
        },
        {
          "q": "RSI 策略通常胜率如何？",
          "choices": [
            {
              "text": "较高 (但盈亏比可能低)",
              "isCorrect": true
            },
            {
              "text": "极低",
              "isCorrect": false
            }
          ],
          "explain": "均值回归策略通常胜率较高，因为价格大部分时间在震荡。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_bb_breakout",
      "title": "策略 5: 布林带突破",
      "subtitle": "波动率爆发交易",
      "concept": "<h3>策略原理</h3>\n<p>布林带突破的核心并不是“突破一条线”，而是交易<b>波动率从收缩到扩张</b>的过程：当带宽长期收窄（市场压缩），突破往往意味着新趋势的启动或加速。</p>\n<div class=\"detail-box\">\n    <h4>1) 基础规则</h4>\n    <p><b>入场:</b> 收盘价突破上轨（多头突破）。</p>\n    <p><b>出场:</b> 回到中轨下方（动能衰减/回归均值）。</p>\n</div>\n<h4>2) 带宽过滤（把假突破砍掉一半）</h4>\n<ul>\n    <li><b>先筛 Squeeze:</b> 只有当带宽处于低位（收口）时才允许交易突破。</li>\n    <li><b>再看扩张:</b> 突破后带宽迅速走阔，往往比“只看收盘穿线”更靠谱。</li>\n</ul>\n<h4>3) 风控与执行（决定它能否长期活下去）</h4>\n<ul>\n    <li><b>假突破很常见:</b> 突破策略必须配合止损（可用中轨/下轨或 ATR 作为动态止损）。</li>\n    <li><b>不要用单笔梭哈:</b> 突破胜率不一定高，但盈亏比通常较好，仓位要按风险预算来定。</li>\n</ul>\n<h4>4) 与均值回归的区别（别搞混）</h4>\n<p>同样是布林带，均值回归是在触轨后赌回归；突破是在收口后赌扩张。两者逻辑完全不同，回测时要分开验证。</p>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "入场：close > upper（突破）",
        "出场：close < mid（回归中轨视为动能衰减）",
        "先用带宽 Squeeze 过滤，再交易扩张",
        "假突破多，止损与仓位管理是核心",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"BB Breakout\", overlay=true)\n[mid, upper, lower] = ta.bb(close, 20, 2)\nif close > upper\n    strategy.entry(\"Long\", strategy.long)\nif close < mid\n    strategy.close(\"Long\")",
      "python_code": "# Python (Backtrader)\nif self.data.close[0] > self.bb.lines.top[0]:\n    self.buy()\nelif self.data.close[0] < self.bb.lines.mid[0]:\n    self.close()",
      "quiz": [
        {
          "q": "布林带突破属于什么类型的策略？",
          "choices": [
            {
              "text": "趋势跟随 (Trend Following)",
              "isCorrect": true
            },
            {
              "text": "均值回归",
              "isCorrect": false
            }
          ],
          "explain": "突破上轨做多是赌趋势会延续。"
        },
        {
          "q": "假突破 (False Breakout) 怎么处理？",
          "choices": [
            {
              "text": "严格止损",
              "isCorrect": true
            },
            {
              "text": "死扛",
              "isCorrect": false
            }
          ],
          "explain": "突破策略假信号多，必须配合止损。"
        },
        {
          "q": "布林带策略中，平仓条件常用什么？",
          "choices": [
            {
              "text": "回归中轨",
              "isCorrect": true
            },
            {
              "text": "突破另一侧轨道",
              "isCorrect": false
            }
          ],
          "explain": "回归中轨意味着短期趋势动能减弱，是常用的止盈点。"
        },
        {
          "q": "%B 指标的作用？",
          "choices": [
            {
              "text": "量化价格在布林带中的位置",
              "isCorrect": true
            },
            {
              "text": "计算带宽",
              "isCorrect": false
            }
          ],
          "explain": "%B = (Price - Lower) / (Upper - Lower)。"
        },
        {
          "q": "什么是“布林带张口”？",
          "choices": [
            {
              "text": "上下轨急速扩张，预示大行情",
              "isCorrect": true
            },
            {
              "text": "上下轨收缩",
              "isCorrect": false
            }
          ],
          "explain": "张口伴随价格突破是强烈的入场信号。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_inside_bar",
      "title": "策略 6: Inside Bar (孕线突破)",
      "subtitle": "Price Action 经典形态",
      "concept": "<h3>策略原理</h3>\n<p>Inside Bar（孕线）本质是<b>波动率压缩</b>：当前 K 线被上一根 K 线完全包住，说明多空进入短暂僵持。孕线突破交易的核心就是：<b>不预测方向，等价格自己选择方向后跟随</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 形态定义</h4>\n    <p><code>high &lt; high[1] and low &gt; low[1]</code></p>\n    <p>上一根被称为 Mother Bar，它的高低点就是临时的结构边界。</p>\n</div>\n<h4>2) 执行方式：双向挂单 + 触发后取消</h4>\n<ul>\n    <li><b>多头突破:</b> 在 Mother Bar 高点上方挂 Buy Stop。</li>\n    <li><b>空头突破:</b> 在 Mother Bar 低点下方挂 Sell Stop。</li>\n    <li><b>关键细节:</b> 一边成交后应取消另一边挂单，避免来回扫单。</li>\n</ul>\n<h4>3) 风控与过滤（决定胜率）</h4>\n<ul>\n    <li><b>止损:</b> 常放在 Mother Bar 的另一侧，结构清晰。</li>\n    <li><b>过滤:</b> 只交易发生在趋势方向上的孕线（例如价格在均线之上只做多突破），可以显著减少假突破。</li>\n    <li><b>量能/波动验证:</b> 突破后如果波动率/成交量没有扩张，往往是假突破。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "high < high[1] and low > low[1]",
        "使用 strategy.entry(stop=price)",
        "Backtrader: Order.Stop",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Inside Bar\")\nisInside = high < high[1] and low > low[1]\nif isInside\n    strategy.entry(\"BuyBreak\", strategy.long, stop=high)\n    strategy.entry(\"SellBreak\", strategy.short, stop=low)",
      "python_code": "# Python (Backtrader)\nis_inside = self.data.high[0] < self.data.high[-1] and \\\n            self.data.low[0] > self.data.low[-1]\nif is_inside:\n    self.buy(exectype=bt.Order.Stop, price=self.data.high[0])",
      "quiz": [
        {
          "q": "Inside Bar 代表市场处于什么状态？",
          "choices": [
            {
              "text": "收敛、犹豫、积蓄能量",
              "isCorrect": true
            },
            {
              "text": "极度疯狂",
              "isCorrect": false
            }
          ],
          "explain": "波动率压缩，随后通常会有扩张。"
        },
        {
          "q": "Mother Bar 是指？",
          "choices": [
            {
              "text": "Inside Bar 的前一根 K 线",
              "isCorrect": true
            },
            {
              "text": "Inside Bar 的后一根",
              "isCorrect": false
            }
          ],
          "explain": "包容当前 K 线的那根大 K 线被称为 Mother Bar。"
        },
        {
          "q": "Stop 单 (停止单) 的作用是？",
          "choices": [
            {
              "text": "价格触及指定位置才触发成交 (突破买入)",
              "isCorrect": true
            },
            {
              "text": "立即成交",
              "isCorrect": false
            }
          ],
          "explain": "Buy Stop 挂在现价上方，用于突破买入；Buy Limit 挂在下方，用于回调买入。"
        },
        {
          "q": "Inside Bar 失败意味着什么？",
          "choices": [
            {
              "text": "突破后迅速拉回 (假突破)",
              "isCorrect": true
            },
            {
              "text": "没有突破",
              "isCorrect": false
            }
          ],
          "explain": "假突破是 Price Action 交易中常见的陷阱。"
        },
        {
          "q": "Hikkake 模式与 Inside Bar 的关系？",
          "choices": [
            {
              "text": "Hikkake 是 Inside Bar 的假突破反转形态",
              "isCorrect": true
            },
            {
              "text": "没关系",
              "isCorrect": false
            }
          ],
          "explain": "Hikkake 专门利用 Inside Bar 突破失败的人群止损进行反向交易。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_turtle",
      "title": "策略 7: Donchian Breakout (海龟交易)",
      "subtitle": "唐奇安通道突破",
      "concept": "<h3>策略原理</h3>\n<p>海龟系统是“趋势跟随 + 严格风控 + 机械执行”的经典范式。它最重要的启发不是某个参数，而是：<b>用规则解决人性问题</b>（追涨杀跌、扛单、过度交易）。</p>\n<div class=\"detail-box\">\n    <h4>1) 唐奇安通道突破（信号层）</h4>\n    <p><b>入场:</b> 突破过去 N 天最高价（做多）/最低价（做空）。</p>\n    <p><b>离场:</b> 跌破更短周期的低点（做多离场）/突破更短周期的高点（做空离场）。</p>\n    <p><b>关键细节:</b> 常用 <code>[1]</code> 引用“上一根 Bar 的通道值”，避免把当前 Bar 的极值当成“已发生”的历史。</p>\n</div>\n<h4>2) 仓位与加仓（系统的灵魂）</h4>\n<ul>\n    <li><b>风险单位 N:</b> 用 ATR 近似波动尺度，让不同品种风险可比。</li>\n    <li><b>头寸规模:</b> N 越大（波动越大）仓位越小。</li>\n    <li><b>金字塔加仓:</b> 价格每向有利方向走 0.5N 加一次仓（前提是趋势延续）。</li>\n</ul>\n<h4>3) 止损与容错（决定能否活下来）</h4>\n<ul>\n    <li><b>初始止损:</b> 常见 2N。</li>\n    <li><b>系统性亏损不可避免:</b> 震荡市会连续假突破，但只要仓位与止损统一，亏损是可控的。</li>\n</ul>\n<h4>4) 强化建议</h4>\n<ul>\n    <li>把手续费、滑点、隔夜跳空纳入回测。</li>\n    <li>避免在极端窄幅震荡中频繁交易，可用 ADX/带宽过滤。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "ta.highest(20)",
        "ta.lowest(10)",
        "经典的趋势跟随系统",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Turtle Breakout\")\nhigh20 = ta.highest(high, 20)[1] // 昨天的20日高点\nlow10 = ta.lowest(low, 10)[1]\n\nif close > high20\n    strategy.entry(\"Long\", strategy.long)\nif close < low10\n    strategy.close(\"Long\")",
      "python_code": "# Python (Backtrader)\nself.high20 = bt.ind.Highest(self.data.high, period=20)\nif self.data.close[0] > self.high20[-1]:\n    self.buy()",
      "quiz": [
        {
          "q": "为什么引用 highest 时要用 [1]？",
          "choices": [
            {
              "text": "避免未来函数 (用到当前Bar的高点)",
              "isCorrect": true
            },
            {
              "text": "语法规定",
              "isCorrect": false
            }
          ],
          "explain": "如果在盘中计算 highest(20) 包含了当前价格，那么只要价格创新高就会触发，这在回测中没问题，但在实盘中需要确认突破的是“过去”的高点。"
        },
        {
          "q": "海龟法则的离场周期通常比入场周期？",
          "choices": [
            {
              "text": "短 (如入场20，离场10)",
              "isCorrect": true
            },
            {
              "text": "长",
              "isCorrect": false
            }
          ],
          "explain": "让利润奔跑，但一旦趋势反转（跌破短期低点）快速离场。"
        },
        {
          "q": "海龟法则如何加仓？",
          "choices": [
            {
              "text": "每上涨 0.5 N 加仓一次",
              "isCorrect": true
            },
            {
              "text": "亏损加仓",
              "isCorrect": false
            }
          ],
          "explain": "Pyramiding (金字塔加仓) 是海龟法则扩大利润的关键。"
        },
        {
          "q": "Donchian Channel 的中轨是？",
          "choices": [
            {
              "text": "(High20 + Low20) / 2",
              "isCorrect": true
            },
            {
              "text": "SMA20",
              "isCorrect": false
            }
          ],
          "explain": "唐奇安通道中轨是最高和最低的平均值。"
        },
        {
          "q": "趋势跟随策略在什么行情下表现最差？",
          "choices": [
            {
              "text": "震荡市",
              "isCorrect": true
            },
            {
              "text": "大牛市",
              "isCorrect": false
            },
            {
              "text": "大熊市",
              "isCorrect": false
            }
          ],
          "explain": "震荡市中突破多为假突破，导致连续亏损。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_grid",
      "title": "策略 8: Grid Trading (网格交易)",
      "subtitle": "震荡市的收割机",
      "concept": "<h3>策略原理</h3>\n<p>网格交易的底层假设是：价格在一个区间内来回波动，你不断“低买高卖”赚取区间震荡的差价。它更像一种<b>做市/库存管理</b>思路，而不是预测趋势。</p>\n<div class=\"detail-box\">\n    <h4>1) 三个关键设计参数</h4>\n    <ul>\n        <li><b>区间:</b> 上下边界决定你愿意在哪些价格持有库存。</li>\n        <li><b>网格间距:</b> 太小吃手续费，太大成交稀疏。</li>\n        <li><b>每格仓位:</b> 决定“库存”累积速度与风险暴露。</li>\n    </ul>\n</div>\n<h4>2) 等差 vs 等比（选错会很难受）</h4>\n<ul>\n    <li><b>等差:</b> 适合价格相对稳定、绝对价格不高的标的。</li>\n    <li><b>等比:</b> 适合跨度较大、不同价位需要保持相似百分比间距的标的。</li>\n</ul>\n<h4>3) 网格最大的敌人：单边行情（破网）</h4>\n<ul>\n    <li><b>下破:</b> 越跌越买，库存越来越重，容易深套。</li>\n    <li><b>上破:</b> 越涨越卖，库存越来越轻，可能踏空。</li>\n</ul>\n<h4>4) 让网格更可控的做法</h4>\n<ul>\n    <li><b>趋势过滤:</b> 在 ADX 较低或带宽较低时启用网格，在趋势期暂停或切换到趋势策略。</li>\n    <li><b>防破网机制:</b> 设定最大库存、区间外止损/对冲、或者区间动态上移/下移。</li>\n    <li><b>费用敏感:</b> 网格是“高换手”策略，手续费、滑点、最小成交量限制会决定生死。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "适合横盘震荡",
        "使用 strategy.order(limit=...)",
        "怕单边破网",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Grid Example\")\n// 简单演示：每跌 1% 买入\ngrid_level = close * 0.99\nstrategy.entry(\"BuyGrid\", strategy.long, limit=grid_level)",
      "python_code": "# Python (Backtrader)\n# 需管理多个 pending orders\nself.buy(exectype=bt.Order.Limit, price=target_price)",
      "quiz": [
        {
          "q": "网格交易最大的风险是？",
          "choices": [
            {
              "text": "单边行情突破网格区间 (破网)",
              "isCorrect": true
            },
            {
              "text": "手续费太低",
              "isCorrect": false
            }
          ],
          "explain": "单边下跌会满仓被套，单边上涨会踏空。"
        },
        {
          "q": "等差网格和等比网格的区别？",
          "choices": [
            {
              "text": "等差是价格差固定，等比是百分比固定",
              "isCorrect": true
            },
            {
              "text": "没有区别",
              "isCorrect": false
            }
          ],
          "explain": "等比网格在价格较高时网格间距更大。"
        },
        {
          "q": "Pine Script 回测网格策略的限制？",
          "choices": [
            {
              "text": "默认最大金字塔层数限制 (pyramiding)",
              "isCorrect": true
            },
            {
              "text": "无法挂单",
              "isCorrect": false
            }
          ],
          "explain": "strategy() 默认 pyramiding=1，网格策略必须调大这个参数 (如 pyramiding=100)。"
        },
        {
          "q": "无限网格 (Infinity Grid) 是指？",
          "choices": [
            {
              "text": "保持持仓价值恒定，上涨卖出部分",
              "isCorrect": true
            },
            {
              "text": "网格数量无限",
              "isCorrect": false
            }
          ],
          "explain": "一种变种，旨在解决上涨踏空问题。"
        },
        {
          "q": "Backtrader 处理网格需要注意？",
          "choices": [
            {
              "text": "订单对象的生命周期管理",
              "isCorrect": true
            },
            {
              "text": "无法处理",
              "isCorrect": false
            }
          ],
          "explain": "需要追踪每个挂单的状态，成交后补单。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_dca",
      "title": "策略 9: DCA (马丁格尔/定投)",
      "subtitle": "成本平均策略",
      "concept": "<h3>策略原理</h3>\n<p>DCA（定投/分批买入）本质是“用时间或回撤换平均成本”。它适用于你愿意长期持有的资产，但它不是稳赚策略：<b>它把止损逻辑换成了资金与时间消耗</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) 两种常见 DCA 形态</h4>\n    <ul>\n        <li><b>时间型定投:</b> 每周/每月固定金额买入（更像资产配置）。</li>\n        <li><b>回撤型加仓:</b> 价格跌到某个比例就加仓（更像“摊低成本”）。</li>\n    </ul>\n</div>\n<h4>2) DCA 与马丁格尔的区别（必须分清）</h4>\n<ul>\n    <li><b>DCA:</b> 通常固定金额/固定数量/固定间距加仓。</li>\n    <li><b>马丁:</b> 亏损后加倍下注，仓位呈指数增长，资金曲线非常脆弱。</li>\n</ul>\n<h4>3) 风控设计（没有风控就等于裸奔）</h4>\n<ul>\n    <li><b>最大层数:</b> 通过 pyramiding 或自定义计数限制加仓次数。</li>\n    <li><b>最大回撤:</b> 到达阈值后停止加仓，必要时止损退出。</li>\n    <li><b>资金分配:</b> 预留现金是策略的一部分，不能全仓起步。</li>\n</ul>\n<h4>4) Pine 实现要点</h4>\n<p>用 <code>pyramiding</code> 允许同方向多次 <code>strategy.entry</code>，并用 <code>strategy.position_avg_price</code> 跟踪均价。回测时要考虑手续费，否则加仓次数越多越吃亏。</p>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "strategy(pyramiding=10)",
        "avg_price 会自动更新",
        "需深口袋",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"DCA\", overlay=true, pyramiding=5)\n\n// 价格比持仓均价跌 5% 加仓\nif strategy.position_size > 0 and close < strategy.position_avg_price * 0.95\n    strategy.entry(\"DCA Buy\", strategy.long)",
      "python_code": "# Python (Backtrader)\nif self.position:\n    if self.data.close[0] < self.position.price * 0.95:\n        self.buy() # 加仓",
      "quiz": [
        {
          "q": "DCA 的核心目的是？",
          "choices": [
            {
              "text": "摊低持仓成本",
              "isCorrect": true
            },
            {
              "text": "追求暴利",
              "isCorrect": false
            }
          ],
          "explain": "通过在低位买入更多份额，降低整体平均成本。"
        },
        {
          "q": "马丁格尔策略与 DCA 的区别？",
          "choices": [
            {
              "text": "马丁是亏损加倍下注，DCA 通常是固定金额/数量",
              "isCorrect": true
            },
            {
              "text": "一样",
              "isCorrect": false
            }
          ],
          "explain": "马丁策略风险呈指数级增长。"
        },
        {
          "q": "在 Pine Script 中获取当前持仓均价的变量是？",
          "choices": [
            {
              "text": "strategy.position_avg_price",
              "isCorrect": true
            },
            {
              "text": "strategy.price",
              "isCorrect": false
            }
          ],
          "explain": "这是系统内置变量，自动计算加权平均价。"
        },
        {
          "q": "如果资金有限，马丁策略最终会导致？",
          "choices": [
            {
              "text": "爆仓 (Blow up)",
              "isCorrect": true
            },
            {
              "text": "必定盈利",
              "isCorrect": false
            }
          ],
          "explain": "市场的不理性可能持续得比你的资金更久。"
        },
        {
          "q": "Backtrader 默认允许加仓吗？",
          "choices": [
            {
              "text": "允许",
              "isCorrect": true
            },
            {
              "text": "不允许",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 默认支持多次 buy()，持仓量会累加。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_pivot",
      "title": "策略 10: Pivot Reversal (枢轴点反转)",
      "subtitle": "左侧交易摸顶抄底",
      "concept": "<h3>策略原理</h3>\n<p>Pivot Reversal 想做的是“在结构位附近抓反转”。它属于逆势/左侧交易，所以核心不是信号多，而是：<b>确认结构 + 控制风险 + 接受少数大亏、靠少数大反转吃回来</b>。</p>\n<div class=\"detail-box\">\n    <h4>1) Pivot 的本质：结构确认（天然滞后）</h4>\n    <p>Pivot Low 的定义需要右侧 R 根 K 线确认，因此它不是实时信号，而是“结构成立后给你一个锚点”。</p>\n    <p><code>ta.pivotlow(left, right)</code> 返回的数值对应的是更早那根 K 线，但只有在确认时刻才出现。</p>\n</div>\n<h4>2) 正确的使用方式</h4>\n<ul>\n    <li><b>画结构位:</b> 把 Pivot High/Low 当作支撑阻力的候选点，然后观察回踩/反抽是否成立。</li>\n    <li><b>配合趋势过滤:</b> 强趋势里逆势抓拐点很容易被趋势“碾压”，可用 ADX 或均线环境限制交易。</li>\n    <li><b>做确认:</b> Pivot 确认后，再用突破/反包/均线回归等确认入场，胜率更高。</li>\n</ul>\n<h4>3) 关于“重绘”的正确理解</h4>\n<ul>\n    <li><b>ta.pivot*</b> 的返回值是确认后的，不会重绘；</li>\n    <li><b>视觉重绘</b> 常来自把确认信号用 offset 画回过去，导致“看起来抓在最低点”。实盘里你当时并不知道。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "ta.pivothigh / ta.pivotlow",
        "信号有滞后 (需要等右侧 N 根确认)",
        "左侧交易",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Pivot Reversal\", overlay=true)\nleft = 4, right = 2\npl = ta.pivotlow(left, right)\n\n// 只有在确认后的那根K线 pl 才有值，否则为 na\nif not na(pl)\n    strategy.entry(\"Long\", strategy.long)",
      "python_code": "# Python (Backtrader)\n# 需自行实现 Pivot 逻辑\n# 检查 data[-2] 是否是低点 (假设 right=2)",
      "quiz": [
        {
          "q": "Pivot Point 信号是实时的吗？",
          "choices": [
            {
              "text": "不是，有滞后",
              "isCorrect": true
            },
            {
              "text": "是实时的",
              "isCorrect": false
            }
          ],
          "explain": "必须等待右侧 N 根 K 线走完，确认中间是极值点后，信号才会出现。"
        },
        {
          "q": "ta.pivotlow(5, 5) 需要等待几根 K 线确认？",
          "choices": [
            {
              "text": "5根",
              "isCorrect": true
            },
            {
              "text": "0根",
              "isCorrect": false
            }
          ],
          "explain": "需要等待右侧 5 根 K 线全部高于中间点，才能确认 Pivot Low。"
        },
        {
          "q": "Repainting (重绘) 在 Pivot 指标中常见吗？",
          "choices": [
            {
              "text": "如果不小心编写，非常常见",
              "isCorrect": true
            },
            {
              "text": "不会重绘",
              "isCorrect": false
            }
          ],
          "explain": "如果在右侧未确认时就画图，后续价格跌破低点，原来的 Pivot 标记会消失（重绘）。ta.pivotlow 返回的值是确认后的，不会重绘，但信号是滞后的。"
        },
        {
          "q": "Pivot 策略适合什么行情？",
          "choices": [
            {
              "text": "震荡区间",
              "isCorrect": true
            },
            {
              "text": "强烈单边趋势",
              "isCorrect": false
            }
          ],
          "explain": "在单边下跌中，Pivot Low 会不断创新低，导致不断抄底被埋。"
        },
        {
          "q": "如何用 Pivot 画支撑阻力线？",
          "choices": [
            {
              "text": "连接多个 Pivot High/Low",
              "isCorrect": true
            },
            {
              "text": "连接收盘价",
              "isCorrect": false
            }
          ],
          "explain": "Pivot 点通常被视为重要的市场结构点。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_mtf",
      "title": "策略 11: Multi-Timeframe (多周期共振)",
      "subtitle": "大周期看趋势，小周期找入场",
      "concept": "<h3>策略原理</h3>\n<p>多周期交易的目标是把“方向选择”和“执行时机”分开：<b>大周期负责告诉你顺势方向，小周期负责给你更好的入场点与止损结构</b>。这样可以减少逆势交易与追高杀低。</p>\n<div class=\"detail-box\">\n    <h4>1) 典型分工</h4>\n    <ul>\n        <li><b>大周期:</b> 趋势/环境过滤（例如日线均线多头排列才允许做多）。</li>\n        <li><b>小周期:</b> 回调入场、结构止损、加仓与减仓执行。</li>\n    </ul>\n</div>\n<h4>2) request.security 的核心（以及它为什么容易“看起来很神”）</h4>\n<ul>\n    <li><code>request.security(symbol, timeframe, expr)</code> 用来在小周期里引用大周期计算结果。</li>\n    <li><b>最大陷阱:</b> 如果你让小周期提前看到“当根大周期的最终结果”，回测会虚高，这就是所谓重绘/未来函数问题。</li>\n    <li><b>更稳的做法:</b> 用已经确认的大周期数据（例如用 <code>daily_close[1]</code> 或默认 lookahead 行为），宁可滞后也不要偷看未来。</li>\n</ul>\n<h4>3) 多周期共振的三条实战建议</h4>\n<ul>\n    <li><b>先定大周期过滤条件:</b> 过滤越清晰，小周期信号越少但质量更高。</li>\n    <li><b>小周期用结构止损:</b> 用最近的 swing low/ATR 设止损，而不是拍脑袋固定点数。</li>\n    <li><b>回测要分段验证:</b> 多周期策略很容易被某一段行情“训练”过拟合。</li>\n</ul>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "request.security(sym, timeframe, expr)",
        "注意 Repainting 问题",
        "lookahead 参数需谨慎",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"MTF Strategy\")\n// 获取日线收盘价\ndaily_close = request.security(syminfo.tickerid, \"D\", close)\n\n// 只有当日线在上涨时，才在当前周期做多\nif daily_close > daily_close[1] and ta.crossover(ta.sma(close,10), ta.sma(close,20))\n    strategy.entry(\"Long\", strategy.long)",
      "python_code": "# Python (Backtrader)\n# cerebro.resampledata(data, timeframe=bt.TimeFrame.Days)\n# 在 strategy 中使用 self.data0 (小周期), self.data1 (大周期)",
      "quiz": [
        {
          "q": "request.security() 的作用是？",
          "choices": [
            {
              "text": "获取其他周期或品种的数据",
              "isCorrect": true
            },
            {
              "text": "加密数据",
              "isCorrect": false
            }
          ],
          "explain": "这是 Pine Script 获取多周期数据的核心函数。"
        },
        {
          "q": "为什么 request.security 容易导致重绘 (Repainting)？",
          "choices": [
            {
              "text": "如果在历史数据中引用了未来的收盘价 (如日线未收盘就获取了最终收盘价)",
              "isCorrect": true
            },
            {
              "text": "网络延迟",
              "isCorrect": false
            }
          ],
          "explain": "在回测历史数据时，小周期 K 线可能会获取到当时尚未形成的“未来”大周期收盘价。应使用 barmerge.lookahead_on 慎重处理，或接受 barmerge.lookahead_off 的滞后。"
        },
        {
          "q": "Backtrader 如何处理多周期？",
          "choices": [
            {
              "text": "传入多个 data feed (adddata)",
              "isCorrect": true
            },
            {
              "text": "不支持",
              "isCorrect": false
            }
          ],
          "explain": "Backtrader 支持多数据源，可以在 strategy 中通过 self.data0, self.data1 访问。"
        },
        {
          "q": "三重滤网交易法 (Triple Screen) 的核心是？",
          "choices": [
            {
              "text": "多周期分析",
              "isCorrect": true
            },
            {
              "text": "三个显示器",
              "isCorrect": false
            }
          ],
          "explain": "Alexander Elder 提出的经典多周期策略。"
        },
        {
          "q": "小周期服从大周期的意思是？",
          "choices": [
            {
              "text": "顺着大周期趋势交易胜率更高",
              "isCorrect": true
            },
            {
              "text": "大周期数据更准确",
              "isCorrect": false
            }
          ],
          "explain": "大周期趋势具有惯性，小周期波动往往是噪音。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "strat_trailing",
      "title": "策略 12: Volatility Stop (移动止损)",
      "subtitle": "让利润奔跑",
      "concept": "<h3>策略原理</h3>\n<p>移动止损 (Trailing Stop) 是“截断亏损，让利润奔跑”名言的直接体现。</p>\n<div class=\"detail-box\">\n    <h4>逻辑机制</h4>\n    <p>止损价不再是固定的，而是随着价格向有利方向移动而跟随移动。</p>\n    <ul>\n        <li><b>多头:</b> StopPrice = Max(High - TrailingDist, PreviousStop)</li>\n        <li><b>特点:</b> 止损线只会上移，不会下移。</li>\n    </ul>\n</div>\n<h4>常见算法</h4>\n<ul>\n    <li><b>点数追踪:</b> 现价回撤 N 个点止损。</li>\n    <li><b>百分比追踪:</b> 现价回撤 N% 止损。</li>\n    <li><b>ATR 吊灯止损 (Chandelier Exit):</b> <code>HighestHigh - 3 * ATR</code>。</li>\n</ul>\n<h4>Pine Script 实现</h4>\n<p><code>strategy.exit(\"Exit\", \"EntryID\", trail_points=100, trail_offset=50)</code></p>\n<p>这表示：当盈利达到 100 点时激活追踪，始终保持现价下方 50 点作为止损。</p>\n<h3>信号  执行  风控（把策略拆成三段式）</h3>\n<ul>\n  <li><b>信号:</b> 负责回答什么时候有交易机会（入场/加仓/退出条件）。</li>\n  <li><b>执行:</b> 负责回答以什么方式成交（市价/限价/条件单、是否允许金字塔加仓）。</li>\n  <li><b>风控:</b> 负责回答亏多少必须走、赚多少怎么锁、仓位多大才合理。</li>\n</ul>\n<h3>边界条件（决定策略能不能落地）</h3>\n<ul>\n  <li><b>信号确认:</b> Pine 回测通常在下一根开盘成交；同一根内多次判断要理解执行顺序。</li>\n  <li><b>滑点与手续费:</b> 不加会高估胜率与收益，尤其是高频/网格/加仓策略。</li>\n  <li><b>最大回撤:</b> 先定义不可接受的回撤，再决定是否允许加仓与止损宽度。</li>\n</ul>\n<h3>参数优化（更像研究而不是调参比赛）</h3>\n<ul>\n  <li><b>先定逻辑再定参数:</b> 只优化少数关键参数，且必须做分段/滚动验证。</li>\n  <li><b>用简单基线对比:</b> 至少与 Buy&Hold 或均线基线比较，避免看起来赚钱但没意义。</li>\n</ul>\n<h3>输入 / 输出（把策略当成函数来想）</h3>\n<ul>\n  <li><b>输入:</b> 标的价格序列（OHLCV）、信号条件（如交叉/突破/形态）、关键参数（周期/阈值）、执行与风控参数（止损/止盈/移动止损/最大层数/手续费滑点）。</li>\n  <li><b>输出:</b> 交易指令（strategy.entry/close/exit）与回测统计结果（收益、回撤、胜率、盈亏比、换手率）。</li>\n</ul>\n<h3>回测 / 实盘注意（避免看起来很美）</h3>\n<ul>\n  <li><b>交易成本:</b> 把手续费、滑点与最小成交量纳入，否则结果通常虚高（网格/DCA/短周期尤其敏感）。</li>\n  <li><b>信号确认:</b> 突破/形态/多周期这类策略，宁可滞后确认，也不要偷看未来（避免重绘/未来函数）。</li>\n</ul>\n",
      "summary": [
        "strategy.exit(trail_points, trail_offset)",
        "保护浮盈",
        "避免过早离场",
        "把策略拆成信号/执行/风控三段式，定位问题更快",
        "回测必须纳入滑点与手续费，高频策略尤其关键"
      ],
      "pine_code": "//@version=5\nstrategy(\"Trailing Stop\")\nif ta.crossover(ta.sma(close, 10), ta.sma(close, 20))\n    strategy.entry(\"Long\", strategy.long)\n\n// 当价格上涨超过 100 点后，启动移动止损，回撤 50 点止损\nstrategy.exit(\"Exit\", \"Long\", trail_points=100, trail_offset=50)",
      "python_code": "# Python (Backtrader)\nself.buy(exectype=bt.Order.StopTrail, trailamount=50)\n# 或者手动在 next() 中调整 stop price",
      "quiz": [
        {
          "q": "移动止损的主要好处是？",
          "choices": [
            {
              "text": "保护浮动利润，同时保留上涨空间",
              "isCorrect": true
            },
            {
              "text": "保证买在最低点",
              "isCorrect": false
            }
          ],
          "explain": "Lock in profits while giving the trade room to grow."
        },
        {
          "q": "吊灯止损 (Chandelier Exit) 基于什么计算？",
          "choices": [
            {
              "text": "最高价 (High) 和 ATR",
              "isCorrect": true
            },
            {
              "text": "收盘价和 RSI",
              "isCorrect": false
            }
          ],
          "explain": "通常是 Highest High - N * ATR。"
        },
        {
          "q": "trail_points=100, trail_offset=50 的意思是？",
          "choices": [
            {
              "text": "盈利100点激活，此时止损在现价-50点",
              "isCorrect": true
            },
            {
              "text": "盈利100点止盈，亏损50点止损",
              "isCorrect": false
            }
          ],
          "explain": "trail_points 是激活阈值，trail_offset 是追踪距离。"
        },
        {
          "q": "Backtrader 有专门的移动止损订单类型吗？",
          "choices": [
            {
              "text": "有 (StopTrail)",
              "isCorrect": true
            },
            {
              "text": "没有，必须手动写逻辑",
              "isCorrect": false
            }
          ],
          "explain": "bt.Order.StopTrail 支持动态调整止损价。"
        },
        {
          "q": "移动止损太紧 (Offset太小) 会导致？",
          "choices": [
            {
              "text": "容易被噪音震荡出局 (Premature Stop-out)",
              "isCorrect": true
            },
            {
              "text": "利润最大化",
              "isCorrect": false
            }
          ],
          "explain": "需要给予市场正常的呼吸空间（波动）。"
        }
      ],
      "category": "量化策略 (Strategies)",
      "isLocked": true
    },
    {
      "id": "ref_ta_all",
      "title": "附录: TA 命名空间全集",
      "subtitle": "Pine Script 技术指标速查手册",
      "concept": "<h3>TA 命名空间全集 (Reference)</h3><p>这里罗列了 Pine Script v5 <code>ta</code> 命名空间下几乎所有的技术分析函数。这是你的<b>速查手册</b>。</p><h4>Moving Averages (移动平均)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.sma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>简单移动平均线 (Simple MA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>pandas: df['close'].rolling(n).mean()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.ema</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>指数移动平均线 (Exponential MA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>pandas: df['close'].ewm(span=n).mean()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.wma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>加权移动平均线 (Weighted MA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.WMA(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.rma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>RSI 专用移动平均 (Wilder's MA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.rma()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.vwma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>成交量加权移动平均 (Volume Weighted MA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.vwma()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.alma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length, offset, sigma</td><td style='padding: 8px; border-bottom: 1px solid #333;'>Arnaud Legoux 移动平均</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.alma()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.swma</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source</td><td style='padding: 8px; border-bottom: 1px solid #333;'>对称加权移动平均 (Symmetrically WMA)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>N/A (需手动实现)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.linreg</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length, offset</td><td style='padding: 8px; border-bottom: 1px solid #333;'>线性回归曲线</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.LINEARREG(close, n)</td></tr></table></div><h4>Oscillators (震荡指标)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.rsi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>相对强弱指数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.RSI(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.stoch</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, high, low, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>随机指标 (K值)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.STOCH...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.tsi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, short, long</td><td style='padding: 8px; border-bottom: 1px solid #333;'>真实强度指数 (True Strength Index)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.tsi()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.mfi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>资金流量指标 (Money Flow Index)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MFI(high, low, close, vol, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.cci</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>顺势指标 (Commodity Channel Index)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.CCI(high, low, close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.roc</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>变动率 (Rate of Change)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.ROC(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.mom</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>动量 (Momentum)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MOM(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.willr</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>威廉指标 (Williams %R)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.WILLR(high, low, close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.cmo</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>钱德动量摆动指标</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.CMO(close, n)</td></tr></table></div><h4>Trend & Volatility (趋势与波动)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.macd</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, fast, slow, signal</td><td style='padding: 8px; border-bottom: 1px solid #333;'>MACD 指标</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MACD...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.bb</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length, mult</td><td style='padding: 8px; border-bottom: 1px solid #333;'>布林带</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.BBANDS...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.kc</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length, mult, useTrueRange</td><td style='padding: 8px; border-bottom: 1px solid #333;'>肯特纳通道 (Keltner Channels)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.kc()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.atr</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>平均真实波幅</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.ATR(high, low, close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.sar</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>start, inc, max</td><td style='padding: 8px; border-bottom: 1px solid #333;'>抛物线转向 (Parabolic SAR)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.SAR(high, low, ...)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.supertrend</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>factor, period</td><td style='padding: 8px; border-bottom: 1px solid #333;'>超级趋势</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.supertrend()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.dmi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>di_len, adx_len</td><td style='padding: 8px; border-bottom: 1px solid #333;'>DMI/ADX 系统</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.ADX / talib.PLUS_DI...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.aroon</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>阿隆指标 (Aroon)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.AROON... (returns up, down)</td></tr></table></div><h4>Volume (成交量)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.obv</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'></td><td style='padding: 8px; border-bottom: 1px solid #333;'>能量潮 (On Balance Volume)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.OBV(close, volume)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.vwap</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source</td><td style='padding: 8px; border-bottom: 1px solid #333;'>成交量加权平均价</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.vwap()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.pvi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'></td><td style='padding: 8px; border-bottom: 1px solid #333;'>正量指标 (Positive Volume Index)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.pvi()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.nvi</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'></td><td style='padding: 8px; border-bottom: 1px solid #333;'>负量指标 (Negative Volume Index)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>Pandas TA: ta.nvi()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.accdist</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'></td><td style='padding: 8px; border-bottom: 1px solid #333;'>累积/派发线 (A/D)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.AD(high, low, close, vol)</td></tr></table></div><h4>Statistics & Math (统计与数学)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.stdev</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>标准差</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.STDDEV(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.variance</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>方差</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.VAR(close, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.correlation</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>src1, src2, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>相关系数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.CORREL(x, y, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.median</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>中位数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>df.rolling(n).median()</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.mode</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>众数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>scipy.stats.mode</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.range</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>极差 (Max - Min)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>rolling max - min</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.percentrank</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>百分位排名</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>scipy.stats.percentileofscore</td></tr></table></div><h4>Analysis Logic (分析逻辑)</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin-bottom: 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align: left;'><th style='padding: 8px; border-bottom: 1px solid #333;'>函数名</th><th style='padding: 8px; border-bottom: 1px solid #333;'>常用参数</th><th style='padding: 8px; border-bottom: 1px solid #333;'>说明</th><th style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e;'>Python 对应</th></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.crossover</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>src1, src2</td><td style='padding: 8px; border-bottom: 1px solid #333;'>上穿 (金叉)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>(s1 > s2) & (s1.shift(1) <= s2.shift(1))</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.crossunder</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>src1, src2</td><td style='padding: 8px; border-bottom: 1px solid #333;'>下穿 (死叉)</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>(s1 < s2) & (s1.shift(1) >= s2.shift(1))</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.barssince</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>condition</td><td style='padding: 8px; border-bottom: 1px solid #333;'>自上次满足条件以来的 K 线数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>需自定义逻辑实现</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.valuewhen</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>condition, source, occurrence</td><td style='padding: 8px; border-bottom: 1px solid #333;'>当条件满足时的值</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>df[cond]['source']...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.highest</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>周期内最高值</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MAX(source, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.lowest</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>周期内最低值</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MIN(source, n)</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.highestbars</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>最高值距离当前的 K 线数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MAXINDEX...</td></tr><tr><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>ta.lowestbars</td><td style='padding: 8px; border-bottom: 1px solid #333; font-family: monospace;'>source, length</td><td style='padding: 8px; border-bottom: 1px solid #333;'>最低值距离当前的 K 线数</td><td style='padding: 8px; border-bottom: 1px solid #333; color: #8b949e; font-size: 12px;'>talib.MININDEX...</td></tr></table></div>",
      "summary": [
        "ta 命名空间包含了所有技术指标",
        "Python 中常用 TALib 或 Pandas TA 库替代",
        "ta.crossover 是最常用的逻辑函数",
        "善用 ta.barssince 和 ta.valuewhen 处理状态逻辑"
      ],
      "pine_code": "//@version=5\nindicator(\"TA Kitchen Sink\", overlay=true)\n\n// 演示一些不常用的 TA 函数\n\n// 1. 抛物线转向 (SAR)\nsar_val = ta.sar(0.02, 0.02, 0.2)\nplot(sar_val, style=plot.style_cross, color=color.white)\n\n// 2. 钱德动量摆动指标 (CMO)\ncmo = ta.cmo(close, 14)\n// 不在主图绘制，仅计算\n\n// 3. 线性回归 (Linear Regression)\nlinreg = ta.linreg(close, 20, 0)\nplot(linreg, color=color.orange, linewidth=2)\n\n// 4. 肯特纳通道 (Keltner Channels)\n[kc_mid, kc_upper, kc_lower] = ta.kc(close, 20, 2)\n// fill(plot(kc_upper), plot(kc_lower), color=color.new(color.blue, 90))\n\n// 5. 威廉指标\nwillr = ta.willr(14)\n\n// 6. 相关性 (Correlation)\n// 计算收盘价与成交量的相关性\ncorr = ta.correlation(close, volume, 20)\n\n// 7. 统计\nstd = ta.stdev(close, 20)\nmedian_price = ta.median(close, 10)\n",
      "python_code": "# Python (使用 Pandas TA 库)\nimport pandas_ta as ta\n\n# 1. SAR\ndf.ta.sar(append=True)\n\n# 2. CMO\ndf.ta.cmo(length=14, append=True)\n\n# 3. Linear Regression\ndf.ta.linreg(length=20, append=True)\n\n# 4. KC\ndf.ta.kc(length=20, scalar=2, append=True)\n\n# 5. WillR\ndf.ta.willr(length=14, append=True)\n\n# 6. Correlation (Pandas rolling corr)\ndf['close'].rolling(20).corr(df['volume'])\n\n# 7. Std & Median\ndf['close'].rolling(20).std()\ndf['close'].rolling(10).median()\n",
      "quiz": [
        {
          "q": "ta.crossover(a, b) 等价于？",
          "choices": [
            {
              "text": "a > b",
              "isCorrect": false
            },
            {
              "text": "a 上穿 b (本根大于，上根小于等于)",
              "isCorrect": true
            },
            {
              "text": "a >= b",
              "isCorrect": false
            }
          ],
          "explain": "crossover 严格定义为当前大于且上一个周期小于等于。"
        },
        {
          "q": "ta.valuewhen(condition, source, 0) 的作用是？",
          "choices": [
            {
              "text": "获取最近一次满足条件时的 source 值",
              "isCorrect": true
            },
            {
              "text": "获取 source 的最大值",
              "isCorrect": false
            }
          ],
          "explain": "valuewhen(cond, src, 0) 返回最近一次 cond 为 true 那一刻的 src 值。"
        },
        {
          "q": "ta.sar 是什么类型的指标？",
          "choices": [
            {
              "text": "趋势跟踪 (Trend Following)",
              "isCorrect": true
            },
            {
              "text": "震荡 (Oscillator)",
              "isCorrect": false
            }
          ],
          "explain": "Parabolic SAR (Stop and Reverse) 是经典的趋势跟踪指标。"
        }
      ],
      "category": "参考资料 (Reference)"
    },
    {
      "id": "ref_pine_params_dict",
      "title": "附录: Pine 参数词典",
      "subtitle": "参数意义 / 名称 / 用法速查（v5）",
      "concept": "<h3>Pine Script v5 参数词典 (Reference)</h3><p>这份“参数词典”专门解决一个痛点：<b>函数看得懂，但不知道每个参数到底干什么</b>。这里按用途把 Pine v5 中最常见的参数名做了一个速查汇总（覆盖日常写脚本的绝大多数场景）。</p><div style='display:flex; gap: 10px; flex-wrap: wrap; margin: 18px 0;'><a href='#ps-params-common' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>通用命名参数</a><a href='#ps-params-input' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>input 参数</a><a href='#ps-params-plot' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>绘图参数</a><a href='#ps-params-strategy' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>策略下单参数</a><a href='#ps-params-security' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>request.security 参数</a><a href='#ps-params-table' style='color: var(--accent-primary); text-decoration: none; border: 1px solid rgba(0,242,255,0.15); padding: 6px 10px; border-radius: 6px; background: rgba(0,242,255,0.05);'>table 参数</a></div><h4 id='ps-params-common'>1) 通用命名参数（很多函数都会有）</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>常见类型</th><th style='padding: 10px; border-bottom: 1px solid #333;'>出现位置</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用 / 说明</th><th style='padding: 10px; border-bottom: 1px solid #333;'>示例</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>title</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>string</td><td style='padding: 10px; border-bottom: 1px solid #333;'>indicator/strategy/plot 系列</td><td style='padding: 10px; border-bottom: 1px solid #333;'>显示名称（数据窗口、图例、设置面板）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, title='EMA')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>shorttitle</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>string</td><td style='padding: 10px; border-bottom: 1px solid #333;'>indicator/strategy</td><td style='padding: 10px; border-bottom: 1px solid #333;'>更短的显示名（常用于图表左上角）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>indicator('X', shorttitle='X')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>color / bgcolor</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>color</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot/shape/label/table</td><td style='padding: 10px; border-bottom: 1px solid #333;'>前景色/背景色。透明度推荐用 <code>color.new(c, transp)</code>。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, color=color.new(color.cyan, 0))</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>editable</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>bool</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot/shape</td><td style='padding: 10px; border-bottom: 1px solid #333;'>是否允许用户在设置中编辑该绘图。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, editable=false)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>display</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>display.*</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot/shape/label</td><td style='padding: 10px; border-bottom: 1px solid #333;'>控制显示位置（主图/数据窗口/状态线等）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, display=display.data_window)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>tooltip</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>string</td><td style='padding: 10px; border-bottom: 1px solid #333;'>input/table.cell/label</td><td style='padding: 10px; border-bottom: 1px solid #333;'>悬停提示说明。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>input.int(14, 'Len', tooltip='周期')</td></tr></table></div><h4 id='ps-params-input'>2) input.* 参数（把脚本做成可调节面板）</h4><p><code>input.*</code> 系列用于创建用户参数面板：<code>input.int</code>/<code>input.float</code>/<code>input.bool</code>/<code>input.string</code>/<code>input.source</code>/<code>input.timeframe</code>/<code>input.symbol</code> 等。</p><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用</th><th style='padding: 10px; border-bottom: 1px solid #333;'>常见用法</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>defval</td><td style='padding: 10px; border-bottom: 1px solid #333;'>默认值（输入框初始值）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>len = input.int(14, 'Length')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>minval / maxval</td><td style='padding: 10px; border-bottom: 1px solid #333;'>数值上下限（防止填错）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>len = input.int(14, 'Len', minval=1, maxval=500)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>step</td><td style='padding: 10px; border-bottom: 1px solid #333;'>步进（滚轮/按钮每次变化幅度）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>atrm = input.float(2.0, 'ATR Mult', step=0.1)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>options</td><td style='padding: 10px; border-bottom: 1px solid #333;'>下拉选项（字符串列表）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>m = input.string('EMA', 'MA', options=['EMA','SMA'])</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>group</td><td style='padding: 10px; border-bottom: 1px solid #333;'>分组（设置面板折叠分区）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>input.int(14, 'Len', group='Signal')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>inline</td><td style='padding: 10px; border-bottom: 1px solid #333;'>同一行排列多个输入控件。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>input.int(14,'A',inline='row1')\ninput.int(28,'B',inline='row1')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>confirm</td><td style='padding: 10px; border-bottom: 1px solid #333;'>修改后需确认才生效（避免误触）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>input.bool(false,'Safe',confirm=true)</td></tr></table></div><h4 id='ps-params-plot'>3) 绘图参数（plot/plotshape/plotchar）</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>出现位置</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用</th><th style='padding: 10px; border-bottom: 1px solid #333;'>示例</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>linewidth</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot</td><td style='padding: 10px; border-bottom: 1px solid #333;'>线宽。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, linewidth=2)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>style</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot/plotshape</td><td style='padding: 10px; border-bottom: 1px solid #333;'>绘制样式（如 <code>plot.style_line</code> / <code>plot.style_histogram</code>）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, style=plot.style_histogram)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>location</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plotshape/plotchar</td><td style='padding: 10px; border-bottom: 1px solid #333;'>绘制位置（K线之上/之下/顶部/底部）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plotshape(cond, location=location.belowbar)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>size</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plotshape/label</td><td style='padding: 10px; border-bottom: 1px solid #333;'>大小（<code>size.tiny</code>~<code>size.huge</code>）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plotshape(cond, size=size.small)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>offset</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot/shape/char</td><td style='padding: 10px; border-bottom: 1px solid #333;'>水平偏移（向左/右移动 N 根）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, offset=-1)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>show_last</td><td style='padding: 10px; border-bottom: 1px solid #333;'>plot</td><td style='padding: 10px; border-bottom: 1px solid #333;'>仅绘制最近 N 根，提升性能。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>plot(x, show_last=300)</td></tr></table></div><h4 id='ps-params-strategy'>4) 策略下单参数（strategy.entry / strategy.order / strategy.exit）</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用</th><th style='padding: 10px; border-bottom: 1px solid #333;'>示例</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>id</td><td style='padding: 10px; border-bottom: 1px solid #333;'>订单/持仓标识（用于 exit 关联）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>strategy.entry('L', strategy.long)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>qty / qty_percent</td><td style='padding: 10px; border-bottom: 1px solid #333;'>下单数量或按权益百分比。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>strategy.entry('L', strategy.long, qty_percent=20)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>limit / stop</td><td style='padding: 10px; border-bottom: 1px solid #333;'>限价/止损触发价（用于挂单）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>strategy.order('L1', strategy.long, limit=close-10)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>trail_points / trail_offset</td><td style='padding: 10px; border-bottom: 1px solid #333;'>跟踪止损（点数/回撤偏移）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>strategy.exit('TX','L', trail_points=150, trail_offset=80)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>when</td><td style='padding: 10px; border-bottom: 1px solid #333;'>条件触发（为 false 时不执行）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>strategy.entry('L', strategy.long, when=cond)</td></tr></table></div><h4 id='ps-params-security'>5) request.security 参数（跨周期/跨品种取值）</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用</th><th style='padding: 10px; border-bottom: 1px solid #333;'>示例</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>symbol</td><td style='padding: 10px; border-bottom: 1px solid #333;'>目标品种（字符串/合约）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>request.security('BINANCE:BTCUSDT','60',close)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>timeframe</td><td style='padding: 10px; border-bottom: 1px solid #333;'>目标周期（如 'D'/'60'）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>request.security(syminfo.tickerid,'D',close)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>expression</td><td style='padding: 10px; border-bottom: 1px solid #333;'>要取回的表达式（series）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>request.security(syminfo.tickerid,'D',ta.rsi(close,14))</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>gaps</td><td style='padding: 10px; border-bottom: 1px solid #333;'>缺口处理（<code>barmerge.gaps_on/off</code>）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>request.security(syminfo.tickerid,'D',close, gaps=barmerge.gaps_off)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>lookahead</td><td style='padding: 10px; border-bottom: 1px solid #333;'>是否未来函数（一般用 <code>barmerge.lookahead_off</code>）。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>request.security(syminfo.tickerid,'D',close, lookahead=barmerge.lookahead_off)</td></tr></table></div><h4 id='ps-params-table'>6) table 参数（做一个“仪表盘/面板”）</h4><div style='overflow-x:auto;'><table style='width:100%; border-collapse: collapse; margin: 12px 0 24px; font-size: 13px;'><tr style='background: rgba(255,255,255,0.05); text-align:left;'><th style='padding: 10px; border-bottom: 1px solid #333;'>函数</th><th style='padding: 10px; border-bottom: 1px solid #333;'>参数名</th><th style='padding: 10px; border-bottom: 1px solid #333;'>作用</th><th style='padding: 10px; border-bottom: 1px solid #333;'>示例</th></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.new</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>position, columns, rows</td><td style='padding: 10px; border-bottom: 1px solid #333;'>创建表格：位置 + 行列数。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>t = table.new(position.top_right, 3, 6)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.new</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>frame_color/frame_width</td><td style='padding: 10px; border-bottom: 1px solid #333;'>外框颜色与粗细。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.new(position.top_right,2,2, frame_color=color.gray, frame_width=1)</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.cell</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>column, row, text</td><td style='padding: 10px; border-bottom: 1px solid #333;'>定位单元格并写入文本。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.cell(t, 0, 0, 'RSI')</td></tr><tr><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.cell</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace; color: var(--accent-primary);'>text_color, bgcolor</td><td style='padding: 10px; border-bottom: 1px solid #333;'>文本颜色与背景色。</td><td style='padding: 10px; border-bottom: 1px solid #333; font-family: monospace;'>table.cell(t,1,0,'42', text_color=color.white, bgcolor=color.new(color.green,80))</td></tr></table></div><p><b>提示：</b>强烈推荐优先使用<b>命名参数</b>（例如 <code>plot(x, color=..., linewidth=..., display=...)</code>），比按顺序填参更不容易出错。</p>",
      "summary": [
        "把常见参数名按用途分组速查",
        "覆盖 input / plot / strategy / security / table 高频参数",
        "优先推荐使用命名参数，减少顺序填参错误"
      ],
      "pine_code": "//@version=5\nindicator('Params Dictionary Demo', shorttitle='PDICT', overlay=true)\n\nsrc = input.source(close, 'Source', group='Inputs')\nlen = input.int(20, 'Length', minval=1, maxval=500, step=1, tooltip='周期越大越平滑', group='Inputs')\nshow = input.bool(true, 'Show', group='Display')\n\nema = ta.ema(src, len)\nplot(show ? ema : na, title='EMA', color=color.new(color.aqua, 0), linewidth=2, display=display.all)\n\nlongCond = ta.crossover(src, ema)\nplotshape(longCond, title='Long', style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny, text='L', textcolor=color.black)\n",
      "python_code": "",
      "quiz": [],
      "category": "参考资料 (Reference)"
    }
  ]
}